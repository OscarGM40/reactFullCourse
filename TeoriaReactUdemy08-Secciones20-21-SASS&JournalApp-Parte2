			SECCION 20 CRUD EN FIRESTORE Y SUBIDA DE ARCHIVOS

¿Qué veremos en esta sección?

1- CRUD hacia Firestore
2- Expandiendo nuestro estore añadiendo otros reducers
3- Seleccionar y subir archivos
4- Animaciones adicionales a nuestra aplicación
5- Limpieza en el logout

Esta sección está enfocada ahora en las entradas de nuestro diario, asegurándose de que grabe únicamente en el documento del usuario autenticado.

		PARTE 254 Continuación del proyecto

Vamos a cambiar el name del usuario hardcodeado en el Sidebar, para ello usaremos un useSelector para que acceda al store:

 const {name} = useSelector(state => state.auth) <- en el div le mandamos el name(debí cometer algún error)

					RESUMEN TODA LA SECCION

Resumen amplio por culpa del SSD: creamos el siguiente reducer notesReducer que  tendrá un arreglo de notas y una nota activa.
Recuerda que con thunk puedo acceder al state en el return:

export const startNewNote = () => {
  return async (dispatch, getState) => {
    const uid = getState().auth.uid;
* GetState es una convención,el argumento es posicional.

Fijate como puedo guardar algo en Firestore(normal database):

  const uid = getState().auth.uid;
    
    const newNote = {
      title: "",
      body: "",
      date: new Date().getTime(), //mls actuales
    };
    
    try {
      /* Desde firebase 9 el método es addDoc y no add */
      const docRef = await db.collection(`${uid}/journal/notes`).add(newNote);
      // console.log(docRef);
      dispatch(activateNote(docRef.id,newNote))
    
Simplemente uso el método add:Promise<>(variableToSave) sobre una colección cualquiera(en este caso será id/journal/notes.
Como estamos con thunk disparamos otra acción sincrona,activando la nota que creamos(justo cuando le dé a new Entry la activo y guardo)

Para hacer el get Firebase trabaja con snapShots(importante):

export const loadNotes = async (uid) => {
   // para obtener la información apunto a un path y le hago get.De igual manera que add devuelve una promise get al resolverse devuelve una collectionSnapshot,ojo
   const notesSnap = await db.collection(`${uid}/journal/notes`).get();
   const notes = [];

   notesSnap.forEach( snapHijo => {
      // console.log(snapHijo.data());
      notes.push({
         id: snapHijo.id,
         ...snapHijo.data(), 
      })
   })
Cada snapShot hija permite acceder a su información con el método data().	

Puedo ordenar la consulta con el método orderBy(field,direction):

 const notesSnap = await db.collection(`${ uid }/journal/notes`).orderBy("date", "desc").get();

IMPORTANTE:fijate que al actualizar la nota activa disparo muchísimas veces una acción(como en un onChange).Esto no es importante,se espera que dispare muchas acciones en una aplicación que utilize redux.
Además es una acción sincrona,lo cual es mucho menos importante que si fuera una acción asíncrona disparada muy seguida.

Recuerda que Firestore no permite campos undefined:

    * Pongo el campo url por defecto a null por si viene undefined
    const { id, url=null,...rest} = note;

    try {
      // db.collection es para trabajar en una coleccion
      // await db.collection(`path...`)
      // lo que quiero ahora es trabajar en un documento,
      await db.doc(`${uid}/journal/notes/${note.id}`)
      .update({ ...url, ...rest })  
      dispatch(refreshNote(note))
      Swal.fire("Saved",rest.title, 'success');

NOTA:fijate que trabajar con una colección es db.collection(pathDelaColeccion) mientras que si quiero trabajar con un documento es db.doc(pathAlDoc).
Fijate que también podia haber echo otras cosas como:
if(!note.url){
  delete note.url; }

CLOUDINARY: recuerda que hay que hacer alguna configuración,pues necesito un preset.Voy a settings(la ruedita) y a la pestaña upload y alli bajo hasta ver 'Add upload preset'.
Alli le doy un nombre y permito subir desde el modo 'unsigned'(Si es signed tienen que estar registrados en cloudinary??).
En la pestaña dashboard tengo todos los detalles :

Account DetailsDownload: YML, PY
Cloud name:	oscargm40
API Key: 945155439291529
API Secret:	***************************
API Environment variable:
CLOUDINARY_URL=cloudinary://***************:***************************@oscargm40
Base delivery URL:	http://res.cloudinary.com/oscargm40 ▼
Secure delivery URL:	https://res.cloudinary.com/oscargm40 ▼
API Base URL:	https://api.cloudinary.com/v1_1/oscargm40 ▼

*NOTA: es a esta API Base URL a donde tengo que apuntar,pero concatenando /upload,con el método POST,y agregando un file,aparte de una cabecera extra(upload_preset).Este upload_preset es el name del preset que hemos creado hace nada(el mio es react-journal-app)
	 
Fijate que CLOUDINARY también permite comprimir los recursos y subir videos.Es una opción excelente

IMPORTANTE: fijate como hizo que un simple texto(un h6 o un span,etc) llamara a un input type file simplemente referenciandolo y simulando su click al hacer click en el primero:

const inputRef = useRef(); <- lo referencio según lenguaje,me valdría un document.querySelector en JS o en Angular una localRef

<input type="file" style={{"display":"none"}} ref={inputRef} onChange={handleInputFile}> 
Ahora el onClick en el span:
<span onClick={openFileSelector}>Imagen</span>
const openFileSelector = () => inputRef.current.click();
Tras abrir el file explorer y elegir una imagen
const handleInputFile= (e) => 
setFile(e.target.file[0])

Fijate como hemos creado un helper que sube la imagen seleccionada y devuelve la url

const fileUpload = (file) => {
  
const cloudUrl= "https://cloudinary.../upload"
 
const form = new FormData();
form.append('file',file)
form.append('upload_preset','react-journal-app');

try{
  const resp = await fetch(cloudUrl,{
    method:'POST',
    body:form <- un form no hay que pasarlo como string
  }
  if(resp.ok){
    const cloudResp = await resp.json(); <- recuerda que me dan un string
    return cloudResp.secure_url
  else{
   return null;
catch(err)...

NOTA: CLOUDINARY me devuelve un string con la url de la imagen o video que suba.Fijate que parecen una opción de la ostia.

Fijate como la libreria Swal permite me usar un loading que tengo que cerrar yo:

    Swal.fire({ 
      title: 'Uploading...',
      text: 'Please wait...',
      allowOutsideClick: false,
      onBeforeOpen: () => {
        Swal.showLoading()
      }
    });
    // llamo a mi helper que me devuelve el campo secure_url
    const fileUrl = await fileUpload(file);

    console.log(fileUrl,'fileUrl')

    Swal.close();
Es con Swal.showLoading(),tengo que cerrarlo.

Puedo usar un directorio en concreto en CLOUDINARY usando el header 'folder':

   const form = new FormData();
   form.append('file', file);
   form.append('upload_preset','react-journal-app')
   form.append('folder', 'react-journal-app'); 

Para borrar procedo igual,apunto al documento con la referencia a la bd y llamo a delete:

export const startDeleteNote = (id) => {
  return async (dispatch, getState) => {
    const uid = getState().auth.uid;
    
    try {
      await db.doc(`${uid}/journal/notes/${id}`).delete();
      dispatch(deleteNote(id));
    } catch (error) {
      console.log(error);
    }
await dbRef.doc(path).delete() <- no puede ser más fácil asin.Como siempre hay que respaldar a redux para que se borre en la db y en la ui.

Fijate como pueden dispararse acciones en varios reducers.Que sean reducers diferentes no tiene importancia alguna.

 export const startLogout = () => {
    return async (dispatch) => {
      await firebase.auth().signOut();
      dispatch(logout); <- dispath al authReducer
      dispatch(notesLogout()) <- pero este es para el notesReducer
    };
  };
  
Esta claro que hay un export const logout en el authActions y un export const notesLogout en el notesAction.Esto es importante,asinto.

	SECCION 22 PRUEBAS CON REDUX,FIREBASE,CLOUDINARY Y AUTENTICACIÓN

  ¿Qué veremos en esta sección?

1- Profundizando en pruebas
2- Pruebas en Firebase y Firestore
3- Pruebas con reducers
4- Variables de entorno de desarrollo, test y producción
5- Pruebas en tareas asíncronas

Esta sección continúa el tema de las pruebas unitarias y de integración con el objetivo de seguir cubriendo temas nuevos. Las pruebas conforme se van avanzando, efectivamente se van haciendo más complejas pero la idea es darles a ustedes las herramientas para que puedan probar cualquier cosa que ustedes necesiten.

					VIDEO 278 JOURNAL APP - TESTING

Configuro el ambiente de test y creo el primer test que compruebe los types.Es más importante de lo que parece comprobar los types ya que si agrego o elimino uno lo sabré fácilmente con el test.

				VIDEO 285 PRUEBAS DE CARGA DE ARCHIVOS

Vamos a probar el fileUpload.js que es un helper que recibe un file y devuelve la URL de CLOUDINARY.

test('should return a valid url', async() => {

   const resp = await fetch('url a una imagen');
   const blob = await resp.blob();
   const file = new File([blob],'image.png') <- el nombre da igual
   const url = await fileUpload(file);

  expect(typeof url).toBe("string") <- comprobar que es un string puede valer

Por último,también compruebo si no se le envía un file válido que la url sea nula  const file = new File([],'horse.jpg')
  const url = await fileUpload(file);
  expect(url).toBe(null) 

						VIDEO 286 SDK DE CLOUDINARY

Fijate que cada vez que arranca la suite de tests se crean varias imágenes.Vamos a usar el SDK para borrarlas inmediatamente:
>npm i cloudinary -D <- fijate que no la necesito en producción,asinto

import cloudinary from "cloudinary";

cloudinary.config({ 
  cloud_name: 'sample', 
  api_key: '874837483274837', 
  api_secret: 'a676b67565c6767a6767d6767f676fe1',
  secure: true
});

* Tengo todos los values en el dashboard.

    // borrar imagen por id
         const segments = url.split('/');
         const imageId = segments[segments.length - 1].split(".")[0];
         const folderName = "react-journal-app"

         cloudinary.v2.api.delete_resources(`${folderName}/${imageId}`,{},() => {

         }     
         );

				CAMBIOS EN REACT ROUTER 6

Ya no se puede acceder a la propiedad activeClasName de un <NavLInk>En su lugar está el método isActive:
<button className={ ({isActive}) => 'nav-item nav-link' + (isActive ? 'active' : '') }
NOTA: fijate que className="navbar" y className={'navbar'} es lo mismo,el segundo es una expresión Javascript que regresa un string,que es lo que necesita el CSS

Ya no es const history = useHistory ahora es const navigate = useNavigate y despues simplemente se llama a navigate('url') 
También ha cambiado el testeo y mockeo de funciones como este hook.Ver documentación o videos si fuera necesario.

				VIDEO 287 PRUEBAS EN EL AUTHREDUCER

Realmente testear esta función es pan comido:


describe("Pruebas en el authReducer", () => {

   const defaultState = {
    uid: "",
    name: "",
  };

  test("should authenticate and set the user", () => {
    const loginAction = {
      type: types.login,
      payload: {
        uid: "1hfkjhh4",
        displayName: "John",
      },
    };

    const state2 = authReducer(defaultState, loginAction);
    expect(state2).toEqual({
      uid: "1hfkjhh4",
      name: "John",
    });
    
  });

  test("should logout and set the user to {}", () => {
      const logoutAction = {
         type: types.logout,
      };
   
      const state2 = authReducer(defaultState, logoutAction);
      expect(state2).toEqual({});
   });

   test("should return the default state when an unkown action is sent", () => {
      const state = authReducer(defaultState, { type: "UNKNOWN" });
      expect(state).toEqual(defaultState);
   })
});

En el siguiente video empezaremos las pruebas en las acciones asíncronas y con redux,lo cual es mucho mas interesante.

					VIDEO 288 PRUEBAS EN ACCIOONES SINCRONAS - UIACTIONS

Vamos a empezar con las acciones sincronas,que son más sencillas.Realmente estas acciones son una función que devuelve un objeto con las propiedades type y payload,asi que el test es straightforward.

 test('should work all actions', () => {
     const setErrorAction = setError('ERROR!!!')
     
       expect(setErrorAction).toEqual({
         type: types.uiSetError,
         payload: 'ERROR!!!'
       }); 

     const removeErrorAction = removeError()
     
       expect(removeErrorAction).toEqual({
         type: types.uiRemoveError,
       }); 

			VIDEO 289 PRUEBAS DE ACCIONES ASÍNCRONAS NOTESACTION.JS

Esto es lo interesante de esta sección.Veamos como testear el startNewNote:

1- de alguna manera debo poder llamar al método startNewNote y que se llame al return async(dispatch,getState) y que se dispare todo el procedimiento.

2- Fijate que startNewNote no recibe argumento alguno y regresa una función(ya que regresamos un async(dispatch,...).Asi pues tenemos una función que regresa una función asíncrona para testear

3- Dentro de la función obtengo el uid,creo una nota y la guardo en Firestore.Tras ello llamo dos veces al dispatch con otras funciones(activateNote y addNewNote)

4- Para ponerle guinda al pastel el guardado en Firestore va a fallar si no estoy autenticado(fijate que en la app si lo estará el usuario,pero no en los tests).

Realmente parece más complicado de lo que es.Lo primero es que vamos a necesitar del store de redux,para ello vamos a usar la librería redux-mock-store:
>npm i redux-mock-store -D
La web aqui: https://www.npmjs.com/package/redux-mock-store

Fijate que este módulo va a crearme un mock de mi store y me va a indicar con que argumentos fue llamado ese store,qué acciones fueron disparadas,...

Como estamos trabajando con acciones asíncronas necesito thunk también:

import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk'

const middlewares = [thunk];
const mockStore = configureStore(middlewares);

Ahora hay que llamar a este método mockStore con un estado válido.Un estado válido es aquel que sea necesario para la prueba,en este caso,necesitabamos un uid y una nota para el startNewNote.
const store = mockStore({
  auth:{
    uid:'ldfjfju543k5'
      }
}) 
La ventaja de esta librería es que ahora puedo disparar acciones con esta instancia 'store':

test('...), async () => {
  await store.dispatch( startNewNote() ); <- fijate que startNewNote era asíncrono asi que await store.dispatch,asinto.

Sin embargo Firebase no me dejará subir la imágen por las reglas que tengo(auth !== null):
7 PERMISSION_DENIED: Missing or insufficient permissions

IMPORTANTE: podría logearme,pero es un error mezclar estas pruebas con lo que debería ser el ambiente de producción que ya he dejado en Firebase.
Asi que vamos a tener que crearnos una base de datos aislada que simule la DB de producción(al fin y al cabo no necesitamos testear si funciona la autenticación en Firebase,se supone que funciona)

			VIDEO 290 CREAR BASE DE DATOS DE DESARROLLO

Vamos a crear una nueva base de datos en Firebase(en realidad no debería tener dos,sino tres:testing,desarrollo y producción,pero por motivos didácticos hemos mezclado desarrollo y producción)

NOTA: cuando se ejecuta el npm run test el ambiente cambia a testing en la app.Esto lo puedo ver en la variable process.env.NODE_ENV(development | test | production).De esta manera puedo cambiar la configuracion de la base de datos.

if (process.env.NODE_ENV === "test") {
  //  configuracion de la db para testing
  firebase.initializeApp(firebaseConfigTesting);
} else {
  //  ambiente development o production
  firebase.initializeApp(firebaseConfig);
}
Veremos otra manera creando variables globales de entorno,aunque esta es válida también.

Como puedo acceder a las acciones que se dispararon en este mock es muy fácil hacer aserciones:
est("startNewNote should create a new note", async () => {
    store.dispatch(startNewNote());
    const actions = store.getActions();

    expect(actions[0]).toEqual({
      type: types.notesActive,
      payload: {
        id: expect.any(String),
        title: "",
        body: "",
        date: expect.any(Number),
      },
    });

    expect(actions[1]).toEqual({
      type: types.notesAddNew,
      payload: {
        id: expect.any(String),
        title: "",
        body: "",
        date: expect.any(Number),
      },
    });

Fijate que store.getActions() devuelve un arreglo de acciones.Por último,al igual que con la imagen,vamos a borrar también el registro.

await db.doc(`TESTING/journal/notes/${actions[0].payload.id}`).delete();

					VIDEO 291 VARIABLES DE ENTORNO

Fijate que si cambiara algo en un futuro en el proyecto de Firebase que tengo enlazado me obligaría a volver al código y cambiarlo en él también.
Para evitar esto vamos a usar los archivos .env que proporciona React:
1- .env <- default
2- .env.local <- sobreescribe localmente y es cargado en cualquier entorno menos el de test
3- .env.development | .env.test | .env.production <- especificos al entorno
4- .env.development.local | .env.test.local | .env.production.local <- sobreescribe localmente al entorno especifico
    
Puedo usar $DOMAIN para apuntar al dominio donde esta la app.Recuerda que process.env.REACT_APP_VARIABLE siempre será un string cuando la rescate del archivo,ya que sólo guarda strings.Si necesitara un número tendré que parsear la llamada a la variable de entorno.
Además en React se usará REACT_APP como prefijo 

Con todo esto  en mente creo los archivos .env.test para un ambiente de test y .env.development 
IMPORTANTE: gitignore por defecto no va a ignorar ningun .env. pero si ignora los .env.local cuando el framework lo escriba él(como con create-react-app o ng new)(los ignora ya que son para local)

Fijate que siempre debería crear varios .env(sobre todo .env.local y .env) para tener una configuración en local distinta de la de remoto(incluo sería buena idea crear .env.local.development y .env.production??).
Ojo,parece que estos nombres de archivos son solo para el frontend.

			VIDEO 292 PRUEBAS EN STARTLOADING NOTES Y STARTSAVENOTES

NOTA: fijate que para acceder al mockStore tengo que usar el método getState sobre el objeto 'store'.

IMPORTANTE:  por defecto el mockStore esta guardando todas las acciones que han sido disparadas.Tiene su lógica que las almacene ya que es uan libreria para testeo.Lo que hay que hacer es limpiar las acciones con clearActions():

beforeEach(() => {
  store.clearActions();
})

NOTA: fallback es como una alternativa a algo.Investigar más.

  test('should load all notes', async () => {
    const uid = store.getState().auth.uid;
    await store.dispatch(startLoadingNotes(uid)); 
    const actions = store.getActions();
    // console.log(actions)
    
    expect(actions).toEqual(expect.arrayContaining([
      {
        type: types.notesLoad,
        payload: expect.any(Array),
      },
    ]));

Realmente vale con comprobar que el payload es un array,da igual qué traiga,me está trayendo los datos,además en el console.log veo que es un array de una posición y sólo tengo un documento,asi que me está haciendo bien el GET ALL(mejor hubiera sido probar con dos xd).

Para la siguiente accion si que hay que traer el id de Firebase y hasrdcodearlo:

test("should update the note", async () => {
    const note = {
      id: "OWBUgUS0dk8L6emyb64m",
      title: "Testing",
      body: "Testing",
      date: new Date().getTime(),
    };

    await store.dispatch(startSaveNote(note));
    const actions = store.getActions();
    // console.log(actions)

    expect(actions[0]).toEqual({
      type: types.notesUpdate,
      payload: note,
    });

    expect(actions[0].payload).toMatchObject({
      id: expect.any(String),
      title: "Testing",
      body: "Testing",
      date: expect.any(Number),
    });

    const docRef = await db
      .doc(`/TESTING/journal/notes/${actions[0].payload.id}`)
      .get();

     console.log(docRef.data());
    expect(docRef.data().title).toBe(note.title);

			VIDEO 293 PRUEBAS EN LA ACCION DE SUBIR UN ARCHIVO

Vamos a testear el startUploading,comprobaremos que se añade el campo url.Fijate que da algun error,como que no se llamó a window.toScroll().Podemos crear nuestra propia propiedad en el setup.js:

const noScroll = () => {};
Object.defineProperty(window,'scrollTo',{value:noScroll,writable:true})

También parece que vale global.scrollTo= jest.fn();

					MOCK DE CUALQUIER FUNCION

NOTA: fijate que nosotros ya hemos probado que el helper funciona,asi que lo que vamos a hacer es un mock para que el helper uploadFile me devuelva una url en concreto   await store.dispatch(startUploading(file)); <- no hace falta probar el startUploading ni crear un file,pues ya lo hemos probado

Para hacer el mock de un archivo se usa jest.mock(ruta,callback) donde en la callback hay que especificar una funcion o más de ese archivo y lo que devuelven.Ejemplo:
jest.mock('../../helpers/fileUpload', () => ({
  fileUpload: jest.fn( () => 'https://hola-mundo.com/cosa.jpg' ),
  anotherFunction: jest.fn(callback)
}))
Fijate que hago el mock de un archivo y despues de cada función que tenga en él,en este caso sólo tengo el helper pero pueden ser varias.Cada función a su vez es un jest.fn(callback) donde en esa cb retorno lo que quiera.

OJO:esto es para la exportación por defecto,si le hice un export const debo usar
jest.mock("../../helpers/fileUpload", () => ({
  __esModule: true,
  default: jest.fn(() => {
    return Promise.resolve("https://hola-mundo.com/cosa.jpg");
  }),
}));

Cuando se utiliza una exportación predeterminada o por default de un modulo de ES6, se debe especificar la propiedad "__esModule: true", Esta propiedad normalmente la genera Babel / TypeScript, pero aquí debe configurarse manualmente.

Es un tema de compatibilidad. Saludos.

				VIDEO 294 PRUEBAS EN LAS ACCIONES DE AUTH

Fijate que no hay diferencia entre declarar algo justo tras el describe o arriba de él.En ambos casos queda de forma global al archivo:

* ESTO PODRIA IR DEBAJO DEL DESCRIBE QUE TAMBIÉN QUEDA GLOBAL
import configureStore from "redux-mock-store";
import thunk from "redux-thunk";

const middlewares = [thunk];
const mockStore = configureStore(middlewares);

const initialState = {}
let store = mockStore(initialState);

describe('Pruebas con las acciones de Auth', () => {

   beforeEach(() => {
      store = mockStore(initialState);
      store.clearActions();
    });
* En cuanto tenga que evaluar asincronia tengo que traerme la store y thunk.

Fijate como para agregar un nuevo proveedor para autenticarme en Firebase ha cambiado un poco la interfaz y ahora es Agregar proveedor.Alli eligo nativa(usuario y email y creo uno para las pruebas).

NOTA: cuando me toque testear el registro(creación) de usuarios,del mismo modo que hemos hecho con CLOUDINARY lo mejor es instalar el SDK(en este caso de Firebase).Con él podré registrar y justo despues borrar ese usuario.

Siempre que sea posible hay que usar los SDK ya que además se instalan en desarrollo,no van a ocupar nada en producción.

NOTA: fijate que comprobar que el registro falla porque el email es unique es una prueba muy válida,ya que probé que efectivamente he conectado con Firebase y que efectivamente hay un usuario ya con ese email,etc...
A veces comprobar que algo no funciona también es un gran test.

					VIDEO 296 PRUEBAS EN EL LOGIN SCREEN

Puede que esta primera vez parezca un poco complejo testear este componente pero tras la primera vez será mucho más fácil además de repetitivo.

NOTA:fijate que al intentar hacer la snapshot me va a dar un error de que el componente necesita en el contexto a react-redux,y que puedo usar un Provider.
Básicamente hay que facilitarle un Provider para que pueda llegar al store.

Fijate que en el componente estoy usando useDispatch,useSelector(con lo que accedo al store) y también disparo acciones con el dispatch de redux.

import { mount } from "enzyme";
import { Provider } from "react-redux";
import configureStore from "redux-mock-store";
import thunk from "redux-thunk";

const middlewares = [thunk];
const mockStore = configureStore(middlewares);

const initialState = {

}

let store = mockStore(initialState);

const wrapper = mount(
  <Provider store={store}>
    <LoginScreen />
  </Provider>
);
No es suficiente con usar el <Provider>.También hay que crear un store de forma similar a como ya hemos echo

					VIDEO 297 TESTEAR STARTGOOGLELOGIN

IMPORTANTE: fijate que cuando use mocks es buena práctica limpiarlos en el beforeEach:
  beforeEach(() => {
    store = mockStore(initialState);
    store.clearActions();
  });

Bien,vamos a simular ese startGoogleLogin,de forma similar a como ya he hecho ya me traigo la accion:
import { startGoogleLogin} from '../../../auth/authActions';

jest.mock('../../../auth/authActions', () => ({
  startGoogleLogin: jest.fn();
}))

Adicionalmente esta vez tengo que hacer un mock del método dispatch para poder disparar la funcion de arriba(pero no era de otra forma??):
store.dispatch.fn()

ya puedo esperar que hacer click en el botón de Google llame a la acción(la cual ya hemos testeado que autentifica)

  test('debe de disparar la accion startGoogleLogin', async () => {
     wrapper.find('.google-btn').simulate('click');
       expect(startGoogleLogin).toHaveBeenCalled();

      })

			VIDEO 298 PRUEBAS EN EL REGISTERSCREEN

Fijate como puedo buscar un componente en el ambiente de test y simplemente preguntar si existe,es decir,si lo he buscado correctamente:

const emailField= wrapper.find('input[name="email"]');
console.log(emailField.exists()); <- si me da un true es que lo he buscado bien

   test("debe de hacer el dispatch de la acción respectiva", () => {
    const emailControl = wrapper.find(".auth__input[name='email']");

    emailControl.simulate("change", {
      target: {
        name: "email",
        value: "",
      },
    });

    wrapper.find("form").simulate("submit", { preventDefault() {} });
    const actions = store.getActions();

    expect(actions[0]).toEqual({
      type: types.uiSetError,
      payload: "Email is not valid",
    });
  });
});
Recuerda que puedo cambiar un <input> con ref.simulate("change",{ target:{ name:"email",value:"newValue"}}) <- donde el name es el name del input(email,phone,etc) y el value el nuevo value.El resto es simular el submit y esperar que se dispare la acción sincrona uiSetError.
En el siguiente video comprobaremos más profundamente este error.

				VIDEO 299 PROBANDO QUE EL MENSAJE DE ERROR EXISTA

Fijate de que forma tán fácil puedo crear otro initialState dentro de un test usando el scope local de const o let:

  test('debe de mostrar la caja de alerta con el error', () => {
    const initialState = {
      auth: {},
      ui: {
        msgError: "Email is not valid",
        loading: false,
      },
    };
    const store = mockStore(initialState);

    const wrapper = mount(
      <MemoryRouter>
        <Provider store={store}>
          <RegisterScreen />
        </Provider>
      </MemoryRouter>
    );

    expect(wrapper.find(".auth__alert-error").text().trim()).toBe(initialState.ui.msgError);
    expect(wrapper.find(".auth__alert-error").exists()).toBe(true);

Dado que estoy en una función ese const store sólo existe dentro de ese test,pudiendole pasar otro estado inicial.Además que es lo que hay que hacer,asinto.

					VIDEO 300 PRUEBAS EN EL APPROUTER

Mucha gente hace mocks de las funciones de Firebase,pero nosotros recuerda que hemos creado una base de datos entera para testing,para realizar las pruebas de la manera más real posible en un ambiente controlado de pruebas.

De nuevo,recuerda que si quiero evaluar con qué argumentos ha sido llamada una función tengo que hacerla mock(por ejemplo el login):

import { login } from "../../../actions/authActions";
import { AppRouter } from "../../routers/AppRouter";

jest.mock("../../../actions/authActions", () => ({
  login: jest.fn(),
}));

Fijate que tras prepara todo como FH dictamina tengo este error:

  Warning: An update to AppRouter inside a test was not wrapped in act(...).
      
      When testing, code that causes React state updates should be wrapped into act(...):
      
      act(() => {
        /* fire events that update state */
      });
      /* assert on the output */

Esto significa que ha sucedido algun cambio (el useEffect) que no está controlado.Tengo que envolver todo dentro de un act( () => {} );

Fijate que puedo hacer el mock de cualquier funcion de una dependencia(hasta ahora sólo habia echo mocks de funciones propias):
import Swal from "sweetalert2";

jest.mock("sweetalert2", () => ({
   fire: jest.fn(),
})); 

Recueda que son a nivel de archivo

					VIDEO 302 PRUEBAS EN EL NOTESCREEN

Recordemos que en cada cambio en el formulario se dispara el efecto, y el efecto dispara el activateNote.Por consecuencia voy a modificar cualquier control del formulario y ver con que argumentos se dispara el activateNote:

  test("debe de llamar el activateNote al cambiar el formulario", async () => {
    wrapper.find("input[name='title']").simulate("change", {
      target: { name: "title", value: "adios" },
    });
    expect(activateNote).toHaveBeenCalled();
    expect(activateNote).toHaveBeenLastCalledWith(1234, {
      title: "adios",
      id:1234,
      body: "mundo",
    });

  });
});
Simplemente simulo el change y ojo,que se dispara dos veces,hay que usar toHaveBeenLastCalledWith.

					VIDEO 303 PRUEBAS EN EL JOURNAL ENTRY

Recuerda que cuando un componente que vaya a testear recibe argumentos simplemente los simulo,no hay más ciencia asinto:
* El comooennte pide una nota,la creo y listo
const nota = {
  id: 10,
  date: 0,
  title: "hola",
  body: "mundo",
  url: "https://algunlugarl.com/foto.jpg",
};
const wrapper = mount(
  <Provider store={store}>
    <JournalEntry {...nota} />
  </Provider>
);

Hacer el mock de una funcion me va a permitir ver cuando,cuantas veces,con qué argumentos,etc se llamó esa función:
store.dispatch = jest.fn(); <- voy a poder ver todo lo relacionado al dispatch de redux(o del que fuera)
En cuanto a la prueba simplemente disparamos el click y vemos que sucede en el dipatch ya que tengo su mock:


  test("debe de activar la nota correctamente", async () => {

    wrapper.find("div.journal__entry").prop("onClick")();
    
    expect(store.dispatch).toHaveBeenCalled();
    expect(store.dispatch).toHaveBeenCalledWith({
      type: types.notesActive,
      payload: {
        id: 10,
        title: "hola",
        body: "mundo",
        date: 0,
        url: "https://algunlugarl.com/foto.jpg",
      },
    }); 
    expect(store.dispatch).toHaveBeenCalledTimes(1);
    expect(store.dispatch).toHaveBeenCalledWith(
      activateNote(nota.id,{...nota}));
  });

Desplegada en : https://journal-app-redux.netlify.app/auth/login
