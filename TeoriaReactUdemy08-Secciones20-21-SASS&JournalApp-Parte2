			SECCION 20 CRUD EN FIRESTORE Y SUBIDA DE ARCHIVOS

¿Qué veremos en esta sección?

1- CRUD hacia Firestore
2- Expandiendo nuestro estore añadiendo otros reducers
3- Seleccionar y subir archivos
4- Animaciones adicionales a nuestra aplicación
5- Limpieza en el logout

Esta sección está enfocada ahora en las entradas de nuestro diario, asegurándose de que grabe únicamente en el documento del usuario autenticado.

		PARTE 254 Continuación del proyecto

Vamos a cambiar el name del usuario hardcodeado en el Sidebar, para ello usaremos un useSelector para que acceda al store:

 const {name} = useSelector(state => state.auth) <- en el div le mandamos el name(debí cometer algún error)

					RESUMEN TODA LA SECCION

Resumen amplio por culpa del SSD: creamos el siguiente reducer notesReducer que  tendrá un arreglo de notas y una nota activa.
Recuerda que con thunk puedo acceder al state en el return:

export const startNewNote = () => {
  return async (dispatch, getState) => {
    const uid = getState().auth.uid;
* GetState es una convención,el argumento es posicional.

Fijate como puedo guardar algo en Firestore(normal database):

  const uid = getState().auth.uid;
    
    const newNote = {
      title: "",
      body: "",
      date: new Date().getTime(), //mls actuales
    };
    
    try {
      /* Desde firebase 9 el método es addDoc y no add */
      const docRef = await db.collection(`${uid}/journal/notes`).add(newNote);
      // console.log(docRef);
      dispatch(activateNote(docRef.id,newNote))
    
Simplemente uso el método add:Promise<>(variableToSave) sobre una colección cualquiera(en este caso será id/journal/notes.
Como estamos con thunk disparamos otra acción sincrona,activando la nota que creamos(justo cuando le dé a new Entry la activo y guardo)

Para hacer el get Firebase trabaja con snapShots(importante):

export const loadNotes = async (uid) => {
   // para obtener la información apunto a un path y le hago get.De igual manera que add devuelve una promise get al resolverse devuelve una collectionSnapshot,ojo
   const notesSnap = await db.collection(`${uid}/journal/notes`).get();
   const notes = [];

   notesSnap.forEach( snapHijo => {
      // console.log(snapHijo.data());
      notes.push({
         id: snapHijo.id,
         ...snapHijo.data(), 
      })
   })
Cada snapShot hija permite acceder a su información con el método data().	

Puedo ordenar la consulta con el método orderBy(field,direction):

 const notesSnap = await db.collection(`${ uid }/journal/notes`).orderBy("date", "desc").get();

IMPORTANTE:fijate que al actualizar la nota activa disparo muchísimas veces una acción(como en un onChange).Esto no es importante,se espera que dispare muchas acciones en una aplicación que utilize redux.
Además es una acción sincrona,lo cual es mucho menos importante que si fuera una acción asíncrona disparada muy seguida.

Recuerda que Firestore no permite campos undefined:

    * Pongo el campo url por defecto a null por si viene undefined
    const { id, url=null,...rest} = note;

    try {
      // db.collection es para trabajar en una coleccion
      // await db.collection(`path...`)
      // lo que quiero ahora es trabajar en un documento,
      await db.doc(`${uid}/journal/notes/${note.id}`)
      .update({ ...url, ...rest })  
      dispatch(refreshNote(note))
      Swal.fire("Saved",rest.title, 'success');

NOTA:fijate que trabajar con una colección es db.collection(pathDelaColeccion) mientras que si quiero trabajar con un documento es db.doc(pathAlDoc).
Fijate que también podia haber echo otras cosas como:
if(!note.url){
  delete note.url; }

CLOUDINARY: recuerda que hay que hacer alguna configuración,pues necesito un preset.Voy a settings(la ruedita) y a la pestaña upload y alli bajo hasta ver 'Add upload preset'.
Alli le doy un nombre y permito subir desde el modo 'unsigned'(Si es signed tienen que estar registrados en cloudinary??).
En la pestaña dashboard tengo todos los detalles :

Account DetailsDownload: YML, PY
Cloud name:	oscargm40
API Key: 945155439291529
API Secret:	***************************
API Environment variable:
CLOUDINARY_URL=cloudinary://***************:***************************@oscargm40
Base delivery URL:	http://res.cloudinary.com/oscargm40 ▼
Secure delivery URL:	https://res.cloudinary.com/oscargm40 ▼
API Base URL:	https://api.cloudinary.com/v1_1/oscargm40 ▼

*NOTA: es a esta API Base URL a donde tengo que apuntar,pero concatenando /upload,con el método POST,y agregando un file,aparte de una cabecera extra(upload_preset).Este upload_preset es el name del preset que hemos creado hace nada(el mio es react-journal-app)
	 
Fijate que CLOUDINARY también permite comprimir los recursos y subir videos.Es una opción excelente

IMPORTANTE: fijate como hizo que un simple texto(un h6 o un span,etc) llamara a un input type file simplemente referenciandolo y simulando su click al hacer click en el primero:

const inputRef = useRef(); <- lo referencio según lenguaje,me valdría un document.querySelector en JS o en Angular una localRef

<input type="file" style={{"display":"none"}} ref={inputRef} onChange={handleInputFile}> 
Ahora el onClick en el span:
<span onClick={openFileSelector}>Imagen</span>
const openFileSelector = () => inputRef.current.click();
Tras abrir el file explorer y elegir una imagen
const handleInputFile= (e) => 
setFile(e.target.file[0])

Fijate como hemos creado un helper que sube la imagen seleccionada y devuelve la url

const fileUpload = (file) => {
  
const cloudUrl= "https://cloudinary.../upload"
 
const form = new FormData();
form.append('file',file)
form.append('upload_preset','react-journal-app');

try{
  const resp = await fetch(cloudUrl,{
    method:'POST',
    body:form <- un form no hay que pasarlo como string
  }
  if(resp.ok){
    const cloudResp = await resp.json(); <- recuerda que me dan un string
    return cloudResp.secure_url
  else{
   return null;
catch(err)...

NOTA: CLOUDINARY me devuelve un string con la url de la imagen o video que suba.Fijate que parecen una opción de la ostia.

Fijate como la libreria Swal permite me usar un loading que tengo que cerrar yo:

    Swal.fire({ 
      title: 'Uploading...',
      text: 'Please wait...',
      allowOutsideClick: false,
      onBeforeOpen: () => {
        Swal.showLoading()
      }
    });
    // llamo a mi helper que me devuelve el campo secure_url
    const fileUrl = await fileUpload(file);

    console.log(fileUrl,'fileUrl')

    Swal.close();
Es con Swal.showLoading(),tengo que cerrarlo.

Puedo usar un directorio en concreto en CLOUDINARY usando el header 'folder':

   const form = new FormData();
   form.append('file', file);
   form.append('upload_preset','react-journal-app')
   form.append('folder', 'react-journal-app'); 

Para borrar procedo igual,apunto al documento con la referencia a la bd y llamo a delete:

export const startDeleteNote = (id) => {
  return async (dispatch, getState) => {
    const uid = getState().auth.uid;
    
    try {
      await db.doc(`${uid}/journal/notes/${id}`).delete();
      dispatch(deleteNote(id));
    } catch (error) {
      console.log(error);
    }
await dbRef.doc(path).delete() <- no puede ser más fácil asin.Como siempre hay que respaldar a redux para que se borre en la db y en la ui.

Fijate como pueden dispararse acciones en varios reducers.Que sean reducers diferentes no tiene importancia alguna.

 export const startLogout = () => {
    return async (dispatch) => {
      await firebase.auth().signOut();
      dispatch(logout); <- dispath al authReducer
      dispatch(notesLogout()) <- pero este es para el notesReducer
    };
  };
  
Esta claro que hay un export const logout en el authActions y un export const notesLogout en el notesAction.Esto es importante,asinto.

	SECCION 22 PRUEBAS CON REDUX,FIREBASE,CLOUDINARY Y AUTENTICACIÓN

  ¿Qué veremos en esta sección?

1- Profundizando en pruebas
2- Pruebas en Firebase y Firestore
3- Pruebas con reducers
4- Variables de entorno de desarrollo, test y producción
5- Pruebas en tareas asíncronas

Esta sección continúa el tema de las pruebas unitarias y de integración con el objetivo de seguir cubriendo temas nuevos. Las pruebas conforme se van avanzando, efectivamente se van haciendo más complejas pero la idea es darles a ustedes las herramientas para que puedan probar cualquier cosa que ustedes necesiten.

					VIDEO 278 JOURNAL APP - TESTING

Configuro el ambiente de test y creo el primer test que compruebe los types.Es más importante de lo que parece comprobar los types ya que si agrego o elimino uno lo sabré fácilmente con el test.

				VIDEO 285 PRUEBAS DE CARGA DE ARCHIVOS

Vamos a probar el fileUpload.js que es un helper que recibe un file y devuelve la URL de CLOUDINARY.

test('should return a valid url', async() => {

   const resp = await fetch('url a una imagen');
   const blob = await resp.blob();
   const file = new File([blob],'image.png') <- el nombre da igual
   const url = await fileUpload(file);

  expect(typeof url).toBe("string") <- comprobar que es un string puede valer

Por último,también compruebo si no se le envía un file válido que la url sea nula  const file = new File([],'horse.jpg')
  const url = await fileUpload(file);
  expect(url).toBe(null) 

						VIDEO 286 SDK DE CLOUDINARY

Fijate que cada vez que arranca la suite de tests se crean varias imágenes.Vamos a usar el SDK para borrarlas inmediatamente:
>npm i cloudinary -D <- fijate que no la necesito en producción,asinto

import cloudinary from "cloudinary";

cloudinary.config({ 
  cloud_name: 'sample', 
  api_key: '874837483274837', 
  api_secret: 'a676b67565c6767a6767d6767f676fe1',
  secure: true
});

* Tengo todos los values en el dashboard.

    // borrar imagen por id
         const segments = url.split('/');
         const imageId = segments[segments.length - 1].split(".")[0];
         const folderName = "react-journal-app"

         cloudinary.v2.api.delete_resources(`${folderName}/${imageId}`,{},() => {

         }     
         );

				CAMBIOS EN REACT ROUTER 6

Ya no se puede acceder a la propiedad activeClasName de un <NavLInk>En su lugar está el método isActive:
<button className={ ({isActive}) => 'nav-item nav-link' + (isActive ? 'active' : '') }
NOTA: fijate que className="navbar" y className={'navbar'} es lo mismo,el segundo es una expresión Javascript que regresa un string,que es lo que necesita el CSS

Ya no es const history = useHistory ahora es const navigate = useNavigate y despues simplemente se llama a navigate('url') 
También ha cambiado el testeo y mockeo de funciones como este hook.Ver documentación o videos si fuera necesario.

				VIDEO 287 PRUEBAS EN EL AUTHREDUCER

Realmente testear esta función es pan comido:


describe("Pruebas en el authReducer", () => {

   const defaultState = {
    uid: "",
    name: "",
  };

  test("should authenticate and set the user", () => {
    const loginAction = {
      type: types.login,
      payload: {
        uid: "1hfkjhh4",
        displayName: "John",
      },
    };

    const state2 = authReducer(defaultState, loginAction);
    expect(state2).toEqual({
      uid: "1hfkjhh4",
      name: "John",
    });
    
  });

  test("should logout and set the user to {}", () => {
      const logoutAction = {
         type: types.logout,
      };
   
      const state2 = authReducer(defaultState, logoutAction);
      expect(state2).toEqual({});
   });

   test("should return the default state when an unkown action is sent", () => {
      const state = authReducer(defaultState, { type: "UNKNOWN" });
      expect(state).toEqual(defaultState);
   })
});

En el siguiente video empezaremos las pruebas en las acciones asíncronas y con redux,lo cual es mucho mas interesante.

					VIDEO 288 PRUEBAS EN ACCIOONES SINCRONAS - UIACTIONS



