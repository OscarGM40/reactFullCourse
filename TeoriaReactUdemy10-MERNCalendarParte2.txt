					SECCION 27 MERN CALENDAR + BACKEND

¿Qué veremos en esta sección?

1- Conexión de nuestro Backend con el Frontend

Esta sección trabajaremos integrando nuestro backend con el frontend hecho en React, que ya tenemos casi terminado, sólo debemos de llamar los servicios y dispara las acciones respectivas que ya tenemos en nuestra aplicación del calendario.

Toda esta sección está enfocada en la parte de la autenticación y manejo del JWT, hay que guardar y estar actualizando el token de autenticación y realizar las pruebas respectivas!

Estamos llegando al final del curso :'(... pero aún falta mucho :D

					VIDEO 364 CREANDO LOS .ENV

Debo acostumbrarme a crear un .env.development y un .env.production.En el primero
 REACT_APP_API_URL="http://localhost:8090"
Y en el segundo al backend de prod
 REACT_APP_API_URL="https://calendar-mern-server.herokuapp.com"
Recuerda que para los cambios en un .env hay que volver a levantar la aplicación.

					VIDEO 365 DISPARAR LOGIN

Vamos a usar nuestro customHooks.Enlazo el formulario con el hook y creo esta acción asincrona,que disparamos en el submit:

export const startLogin = (email, password) => {
  return async (dispatch, getState) => {
    console.log(email, password);
  };
};

			VIDEO 367 REALIZAR LA PETICIÓN HTTP PARA LOGEARSE

 Como siempre voy a tener dos tipos de peticiones en mi aplicación,unas que requieren el envio del token y otras que no.La mejor manera de manejar esto es crearse un helper.Además no vamos a usar axios,para no instalar una dependencia.
Realmente hay varias formas de abordar esto pero siempre tengo que hacer algo al respecto:
const fetchSinToken = (endpoint, data, method = "GET") => {
  const url = `${process.env.REACT_APP_API_URL}/${endpoint}`;
  console.log(url, "url");

  const headers = {
    "Content-type": "application/json",
  };

  if (method === "GET") {
    return fetch(url);
  } else {
    return fetch(url, {
      method,
      body: JSON.stringify(data),
      headers,
    });
  }
};

Si el login es exitoso voy a guardar el token y además,como sé que dura 2 horas,otra propiedad relacionado con esto:
    if(body.ok){
      localStorage.setItem("token", body.token);
      localStorage.setItem("token-init-date", new Date().getTime());
    }

NOTA: fijate que puedo usar la API fetch porque estoy en un navegador(es el propio navegador el que realiza la petición).Si estuviera en un backend no tengo acceso a la API fetch y tengo que usar axios o node-fetch.Asi que,porque no aprovechar que estoy en el browser?

IMPORTANTE: puedo tomar estos archivos xxxActions como una zona de declaración de funciones.Puedo declarar las que quiera o necesite,sin embargo tengo que contestarme a una pregunta cada vez que cree una:
La pregunta es,¿la acción la desarrollo aqui(asincrona)o es sincrona y no me dice realmente que hay que hacer?.Si es la segunda debo usar el xxxReducer correspondiente para desarrollar su código.
const login = (user) => ({
  type: types.authLoginSuccess,
  payload: user,
})
Es decir,o la desarrollo alli o sólo define el payload y type y la desarrollo en el Reducer,pero siempre la desarrollaré y además coinciden con asincronas y síncronas.
				VIDEO 368 CREACIÓN DE UN NUEVO USUARIO

Antes de nada,fijate como validar todo perfecto en el backend ahora me permite disparar Swal fácil:
      dispatch(login({
        uid:body.uid,
        name:body.name,
      })) ;
    }else {
      Swal.fire('Error', body.msg, 'error');
    }

Realmente es el mismo procedimiento que para el login sólo que apuntando a otro endpoint.Debo logearlo y redireccionar a la app tal como ha diseñado FH el backend.
Fijate que nos falta proteger las rutas y persistir la autenticación.

				VIDEO 369 MANTENER EL ESTADO DE LA AUTENTICACIÓN

Al hacer un refresh(actualizar el navegador) tengo que mirar en el localStorage por el token.Ya tenemos un servicio para esto.

A partir de ahora hay que crear el segundo servicio que mande siempre un token:

const fetchConToken = (endpoint, data, method = "GET") => {
  const url = `${process.env.REACT_APP_API_URL}/${endpoint}`;
  // console.log(url, "url");
  
  const token = localStorage.getItem("token") || "";
  const headers = {
    "Content-type": "application/json",
    "x-token": token
  };

  if (method === "GET") {
    return fetch(url,{
      method,
      headers
    });

Realmente podriamos meter la acción que realice la petición al refrescar en un efecto en el index.js o el AppRouter.jsx o el CalendarApp.Lo haremos en el AppRouter:

  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(startChecking());
  }, [dispatch]);
Fijate que dispatch nunca va a cambiar,aún asi lo meto.

En cuanto a la acción simplemente hace el GET al renew.Muy sencilla.Sin embargo nos olvidamos de devolver el uid y name en el backend.
export const startChecking = () => {
  return async(dispatch, getState) => {
    const response = await fetchConToken("auth/renew");
    const body = await response.json();
    console.log(body);
    
    if(body.ok){
      localStorage.setItem("token", body.token);
      localStorage.setItem("token-init-date", new Date().getTime());
      
      dispatch(login({
        uid:body.uid,
        name:body.name,
      }));
    }else{
      Swal.fire('Error', body.msg, 'error');
      dispatch(checkingFinish());
    }
  }
}

const checkingFinish = () => ({
  type: types.authCheckingFinish,
});

					VIDEO 371 PROTECCION DE RUTAS

Realmente si tengo un uid y name sé que estoy autenticado.Al final con la versión 6 ha cambiado mucho todo:

PrivateRoute.js:

import React from "react";
import { Navigate } from "react-router-dom";
import { useSelector } from "react-redux";

const PrivateRoute = ({ children }) => {
  const { uid } = useSelector((state) => state.auth);
  return !!uid ? children : <Navigate to="/login" />;
};

PublicRoute.js:

import { useSelector } from "react-redux";
import { Navigate } from "react-router-dom";

const PublicRoute = ({ children }) => {
  const { uid } = useSelector((state) => state.auth);

  return !!uid ? <Navigate to="/" /> : children;
};

export default PublicRoute;

Fijate en que ahora comprobaré aqui la condición que hace estar autenticado, y fijate en el uso de children,para que si se cumple o no se renderize esa prop

En el AppRouter.js:
  <BrowserRouter>
      <Routes>
        <Route path="/login" element={
          <PublicRoute>
            <LoginScreen />
          </PublicRoute>
        }
        />

        <Route path="/*" element={
          <PrivateRoute>
            <CalendarScreen />
          </PrivateRoute>
        }
        />
      </Routes>
    </BrowserRouter>
export default PrivateRoute;

Muy raro desde la v6.Debería hacer un tutorial sobre ello.

							VIDEO 372 LOGOUT

Realmente es bastante sencillo.El botón disparará esta acción:

 const handleLogout = () => {
    dispatch(startLogout());
  };
Y la acción remueve todo:
export const startLogout = () => {
  return (dispatch, getState) => {
    /* las modificaciones del localStorage se consideran asíncronas */
    localStorage.removeItem("token");
    localStorage.removeItem("token-init-date");
    dispatch(logout());
    
  };
}

const logout = () => ({
  type: types.authLogout,
});

Esta acción logout la declaro en el authReducer:

    case types.authLogout:
      return {
        ...state,
        uid: null,
        name: null,
      };
* En realidad podia devolver sólo checking : false ya que si no pongo algo lo va a borrar,si no pongo uid:null también lo va a borrar.
Fijate que mis archivos PrivateRoute y PublicRoute están escuchando por un cambio en la propiedad uid y el logout la cambia(poniendola a null o undefined),con lo que detectan un cambio y renderizan de nuevo el componente,sacandome de la aplicación.Genial.

				SECCION 28 EVENTOS DEL CALENDARIO - CRUD

Realmente ya tenemos casi todo hecho en el backend,sólo queda disparar las acciones para el CRUD de eventos del Calendar.

¿Qué veremos en esta sección?

1- Eventos del calendario + backend

Toda esta sección está enfocada en hacer persistentes nuestros cambios y eventos del calendario utilizando nuestro backend, disparando acciones asíncronas que terminan ejecutando las acciones síncronas que habíamos definido anteriormente.

			VIDEO 377 CREANDO UN EVENTO EN EL CALENDARIO

Realmente ya teniamos echo la acción síncrona contra el reducer,pero ahora vamos a guardarlo también en la base de datos.Muy sencillo:

export const eventStartAddNew = (event) => {
  return async (dispatch,getState) => {
    const { uid, name } = getState().auth
    try {
      const response = await fetchConToken("events",event,"POST");
      const body = await response.json();
      
      if(body.ok) {
        event.id = body.evento._id;
        event.user = {
          _id: uid,
          name: name,
        }
        dispatch(eventAddNew(event));
      }
    } catch (error) {
      console.log(error)
    }
      
  }
}

const eventAddNew = (event) => ({
  type: types.eventAddNew,
  payload: event
})
Fijate como para acceder al state de Redux usamos de nuevo getState().auth.

			VIDEO 378 MOSTRAR EVENTOS DESDE LA BASE DE DATOS

De nuevo es otro que tenemos en local ya echo,sólo falta hacer la petición.Fijate que el punto ideal es cuando se cargue el calendario por primera vez,luego un efecto en el calendarScreen es la solución:

useEffect( () => {
  dispatch(eventStartLoading())
},[dispatch])
Aunque me pida el dispatch nunca cambiará.

Sin embargo,vamos a tener un problema ya que la fecha viene como String y necesitamos que sea un object tipo Date.Lo mejor será crearse un helper

				VIDEO 379 CONVERTIR STRINGS A OBJECTS TIPO DATE

IMPORTANTE:para tener la ayuda de los arrays fijate como le asigno un valor por defecto al helper.

export const prepareEvents = (events=[]) => {
...
Muy inteligente Fernando.Para pasar Strings a fechas,y,realmente,siempre que vaya a trabajar con Dates debería usar algo como moment.
Moment es genial y me va a ayudar a trabajar con fechas fácilmente.

El helper va a ser muy sencillo con moment:
import moment from "moment";

export const prepareEvents = (events=[]) => {

  return events.map(event => 
    {
      event.start = moment(event.start).toDate();
      event.end = moment(event.end).toDate();
      return event;
    });
}

Por último quiero que cada evento se vea de un color según sea mío o de otros.Esto lo tengo hardcodeado en el calendarScreen.Esto lo puedo saber comparando el event.user.id con el del token que tenemos en el store de cada uno.

  backgroundColor:( uid === event.user.id 
         ? '#3e9edfcf' 
         : '#574e4c'),

				VIDEO 380 ACTUALIZAR EVENTO

REcuerda que solo debería poder editar mis eventos y que lo puedo hacer con el doble click.
export const eventStartUpdate = (event) => {
  return async (dispatch, getState) => {
    try {
      const response = await fetchConToken(`events/${event.id}`, event, "PUT");
      const body = await response.json();

      if (body.ok) {  
        dispatch(eventUpdate(event));
      }else{
        Swal.fire("Error", body.msg, "error");
      }
    } catch (error) {
      console.log(error);
    }
  };
};
Realmente con el backend ya nos vale pues no voy a poder editar el evento de otro.

				EXTRA CLOSURES Y MULTIPLE ARROW FUNCTIONS

El uso de múltiples arrow functions en JS indica que estoy usando una 'closure'.Una closure es una función que retorna otra función.Esto es posible porque una arrow function retorna lo que sea que tenga al lado derecho de la arrow:
const f = () => .... <- retorno esto

Asi pues si proveo una funcion en el lado derecho de la flecha,la arrow function original será una closure,pues retorna una función.

const example = () => () => {
  console.log('I am a closure')
}
NOTA:closure es cierre,clausura,cerramiento,...

Para llamarlas se usarán tantos pares de paréntesis como funciones:
const addNumbers = a => b => a + b;
addNumbers(2)(2) // retorna 4 fijate que debo llamar dos funciones
Esta forma de llamar con grupos de paréntesis se llama curring

Pero,¿porqué usar closures en JS?: La razón principal suele ser contener,persistir o proteger un valor del scope exterior.

						VIDEO 381 ELIMINAR UN EVENTO

Recuerda que tengo el evento en el evento activo y que se borraba al pulsar el botón de borrar:

En el DeleteEventFab.js
  const handleDelete = () => {
    dispatch(eventStartDeleting())
  }

La petición simplemente busco el id de la nota activa,que lo está para haber llegado hasta aqui

Fijate que aún tenemos un error,si seleccionamos un activeEvent en el logout no lo limpiamos.Para corregir esto simplement creo una acción en el eventActions que limpie los eventos y la disparo desde las authActions.
Fijate como no hay problema alguno en interrealcionar acciones o reducers.

    case types.eventLogout:
      return {
        ...initialState,
      };

Nada me impide disparar eventos en cualquier reducer que apuntan a otro:

En el authLogout...

    localStorage.removeItem("token");
    localStorage.removeItem("token-init-date");
    dispatch(eventLogout()) <- uno para el eventReducer
    dispatch(logout()); <- y otro para el authReducer

			SECCION 28 DESPLEGAR VERSIÓN DE PRODUCCIÓN EN HEROKU

¿Qué veremos en esta sección?

1- Despliegues a producción

Aquí tomaremos nuestra aplicación de React para generar el build de producción y desplegarlo en nuestro backend en Heroku.

		VIDEO 385 GENERAR VERSIÓN DE PRODUCCIÓN Y DESPLEGARLA EN HEROKU

Recuerda que ya hemos especificado en nuestro servidor que vamos a usar una carpeta pública.Simplemente hay que reemplazar ese index.html por la versión que genere el npm run build del frontend.

Fijate que el build me creará varios .chunk.js o .chunk.css.Estos chunk son pequeñas piezas de código que se cargarán cuando sea necesario.

Ya sólo es copiar todo el contenido del build a la carpeta public(borrando lo que habia).Ahora hay que hacer un nuevo despliegue a Heroku.PAra ello voy al folder con el backend:
>git add .
>git commit -m "..."
>git push heroku master

No ha podido ser más fácil.

				SECCION 29 TESTING DE CALENDAR APP	

Esta sección va a ser la más complicada,ya que tenemos un backend y un frontend además de múltiples componentes interconectados.
No testearemos todo,pues la aplicación es bastante grande.

NOTA IMPORTANTE: En un trabajo real nunca debimos haber desplegado la app en producción(xd) antes de hacer los tests.

¿Qué veremos en esta sección?

1- Finalización con las últimas pruebas necesarias
2- Pruebas con Fetch
3- Mocks
4- Simulaciones
5- Mocks parciales
6- Store
7- MockStore
8- Eventos de componentes de terceros
9- Simular acciones

Esta es la sección de pruebas más complicada de todas, pero no imposible, nuevamente el objetivo de la misma es darles a ustedes todo el repertorio de pruebas que podrán necesitar en sus aplicaciones hechas o futuras.

					VIDEO 388 INICIO DE LAS PRUEBAS

Pasos para establecer ambiente pruebas en React

1 Instalar enzyme: npm install enzyme -D
2 Instalar enzyme-to-json: npm i enzyme-to-json -D
3 Instalar adaptador para React 17: npm install --save-dev @wojtekmaj/enzyme-adapter-react-17
4 Instalar redux-mock-store(si uso redux): npm i redux-mock-store -D

En el Setup.js:
import Enzyme from 'enzyme';
import Adapter from '@wojtekmaj/enzyme-adapter-react-17';
import {createSerializer} from 'enzyme-to-json';
 
 
Enzyme.configure({ adapter: new Adapter() });
expect.addSnapshotSerializer(createSerializer({mode: 'deep'}));

Aparte de configurar todo hago una pequeña prueba contra los types.js

				VIDEO 389 PRUEBAS EN NUESTRO HELPER DEL FETCH

Vamos a hacer pruebas sobre nuestro helper fetch.js(el que hace peticiones con y sin token).Nos interesa probar que funcionan como esperamos(que se llame sin el token y exitosamente y que el fetch con el token realmente lo envie y llegue bien)

Si bien puede parecer que no está muy claro qué testear,realmente,simular el login me puede valer,comprobando que si mando un user que ya exista me devuelven un token y su name correctamente,lo cual es muy sencillo.Aparte, ijate que la URL la traemos de los environments.

NOTA: este error => Error: Error: connect ECONNREFUSED 127.0.0.1:80 es algo que esperamos,ya que no he definido el .env.test y no encuentra la base URL de esta linea en el file original:
 const url = `${process.env.REACT_APP_API_URL}/${endpoint}`;
NOTA: los archivos .env van por especificidad,siendo el .env el menos especifico.
Un .env.test.local es más especifico que un .env.test y aún más que un simple .env.
Es decir que podría usar .env.development.local para desarrollo local y otro .env.development que va a ser menos especifico para desarrollo en remoto.
Además puedo inferir contenido en los valores de las variables,no tienen porque ir los valores hardcodeados:
REACT_APP_VERSION=${npm_package_version} <- $DOMAIN es muy usada también

Fijate que al usar .env.development no especifiqué nada para un ambiente de test.Genial,todo claro.

				VIDEO 390 PRUEBAS EN EL FETCH CON TOKEN

Fijate que es buena idea testear que la resp del helper sea una instance de Response. 
NOTA: perfectamente puedo trabajar con el localStorage(sin simularlo) dentro de mis pruebas,y como debo mandar un token válido podría guardar el token del login que hice en el test anterior ya que tengo que mandar un token válido y me acaban de dar uno.

En la prueba anterior lo último que hago es asignarlo a una variable let
token = body.token;

Puedo testear cualquier cosa,pero una respuesta como está me confirmará que viaja el token(ya que la pude hacer) y que se hace el fetch de ese endpoint:

  test("fetch con token debe de funcionar", async () => {
    localStorage.setItem("token", token);

    const resp = await fetchConToken(
      "events/61ad1a4cb2f69f692ba17a79",
      {},"DELETE");
    const body = await resp.json();
    expect( body.ok ).toBe(false);
    expect(body.msg).toBe("Evento no encontrado");

    }); <- Genial

				VIDEO 391 PRUEBAS EN LAS ACCIONES DEL AUTHACTIONS.JS

NOTA: recuerda que con la librería react-modal puedo crear un Modal super-configutable fácilmente(el cual debí haber implementado en mi app).Además que se puede cerrar y abrir con redux.
Fijate que tendré que hacer varias configuracione ya que voy a usar dispatch,usar el store,mockear Swal...

PASOS A SEGUIR 
1- como necesitaré un store ocupo redux-mock-store
import  configureStore from 'redux-mock-store';

2- Dado que son acciones que regresan funciones,es decir,que hayé asincronia en ellas necesito thunk
import thunk from 'redux-thunk';

3- como quiero la ayuda del tipado me traigo a jest-dom:
import '@testing-library/jest-dom';

/* debo configurar el store tras importarlo */
const middlewares = [thunk];
const mockStore = configureStore(middlewares);

/* de momento uso un objeto vacio como initial State para el store */
const initState = {};
/* ya si proveo una instancia de este store fake */
let store = mockStore(initState);


describe('Pruebas en el authActions.js', () => {
    /* quiero reiniciar al state inicial en cada prueba,ya que las acciones que se hayan ejecutado lo cambian */  
    beforeEach(() => {
        store = mockStore(initState);
    });

  
})

Ya puedo ejecutar una prueba,podríamos empezar con el startLogin,comprobando que realmente guarde en el localStorage,que llame a Swal.fire si hay un error,...
REalmente es más sencillo de lo que parece asinto:

    test('startLogin actua correctamente', async () => {

      await store.dispatch(startLogin('test@test.com','ABCAbc123')); 
      const actions = store.getActions();

      console.log(actions[0]);
      expect(actions[0]).toEqual({  
        type: types.authLoginSuccess,
        payload: {  
          uid: expect.any(String), // <- podria hardcodearlo
          name: 'Jane',
        }
      })
    })

 Toda la configuración anterior me permite disparar cualquier acción con store.dispatch y ver sus consecuencias.Increíble.

DAdo que dijimos que queremos mirar en el localStorage vamos a hacer un mock de eĺ.Recuerda que es con la interfaz Storage y fijate como estoy mockeando el setItem sólo!:
Storage.prototype.setItem = jest.fn();

Además ,cada vez que use jest.fn() debería limpiar sus mocks con jest.clearAllMocks antes de cada prueba por motivos similares a limpiar el store:

beforeEach( () => {
  store = mockStore(initState);
  jest.clearAllMocks();
} <- siempre limpiar todo,asinto

* Las funciones van por referencia,lógicamente
expect(localStorage.setItem).toHaveBeenCalledTimes(2); 
expect(localStorage.setItem).toHaveBeenCalledWith("token",expect.any(String));

IMPORTANTE: yo puedo acceder a los argumentos con los que son llamadas cualquier función a la que le haga un mock con jest.fn().Para ello accedo a la referencia a la funcion + la propiedad mocks porque es un mock y + la propiedad calls ya que quiero los argumentos de la llamada.
Esto siempre va a ser un arreglo de arreglos,siendo el arreglo interior de dos posiciones,manejando pares de clave-valor.Ejemplo:
[ ["token","...],["token-init-date",3434346] ]

*Con esto en mente puedo acceder a sus argumentos,puedo hacer un mock del setItem del localStorage y ver el token,por ejemplo:
Storage.prototype.setItem = jest.fn() <- le hago el mock
* disparo una action con mi mock store que haga algo en el store 
await store.dispatch...
* puedo mirar el valor de los argumentos de esa funcion mock
console.log(localStorage.setItem.mocks.calls[0][1]) <- Genial.

			VIDEO 392 PRUEBAS CON UN LOGIN INCORRECTO

Esta prueba es bien fácil.Puedo meter una password incorrecta y esperar que actions sea un arreglo vacío y/o mockear a Swal.fire y esperar que se haya llamado:

await store.dispatch(startLogin("test@test.com",'lkfjslkfklf'));
  const actions = store.getActions();
  expect(actions).toEqual([]);
  expect(Swal.fire).toHAveBeenCalled()

NOTA: para hacer el mock de una función ya he visto como lo hemos hecho con el setItem del localStorage luego puedo hacer lo mismo con Swal.fire:

Swal.fire = jest.fn()

Sin embargo,hay otra forma,un poco más compleja,pero también permite configurar más profundamente el mock que crearé:

* Fijate que aqui estoy mockeando una libreria entera!
jest.mock('sweetalert2', () => ({ <- devuelvo un Object literal como 2º arg
  fire: jest.fn();
})	
Lo bueno de esta forma es que podría mockear varias propiedades y métodos a la vez,podría mockear delete,open,etc.. si las tuviera
Ambas formas van a crear un mock sobre Swal.fire,en este ejemplo.Genial.

expect(Swal.fire).toHaveBeenCalledWith("Error","El password es incorrecto","error");
expect(Swal.fire.mock.calls[0][0]).toBe("Error");
Podría hacer lo mismo pero mandando un email incorrecto.Yo no lo haré pero Fernando si lo hizo.

			VIDEO 393 PRUEBAS CON EL REGISTRO DE USUARIOS

LLegados a este punto,pudiera parecer que el register es exactamente igual que el login,y si que lo es,pero sólo la primera vez,ya que me guardará el usuario en la DB y la segunda vez va a tirar error,cambiando el comportamiento.
Hay varias soluciones que podría usar,como borrar el usuario creado llamando al endpoint con el DELETE,pero seguń tenemos la apicación sólo desactivamos al usuario.
Lo que vamos a hacer es hacer un mock del fetchSinToken(ya que sabemos que funciona pues acabamos de hacer dos pruebas con él).Genial.
Además,sólo queremos el mock en esta tercera prueba.

PASOS
1º Importar todo el archivo
import * as fetchModule from "../../helpers/fetch";

2º Hago el jest.fn() de la función que quiera,pero ojo con posibles necesidades extras,en este caso necesito que esa funcion llame al json() y que me devuelva ciertos valores(no es que lo necesite,es que es lo que quiero simular):

test('startRegister actua correctamente', async () => {
  fetchModule.fetchSinToken = jest.fn( () => ({
    json(){
      return {
        ok:true,
        uid:'123',
        name:'carlos',
        token:'11ffaff'
}));
Asi es como se simula no sólo una función,sino lo que necesite para funcionar.Lógicamente he simulado incluso el retorno de la función(que llamará a un método json que devuelve esos valores,no necesito más,solo me importa que se llame json y que devuelva esas propiedades:

 expect(actions[0]).toEqual({
      type: types.authLoginSuccess,
      payload: {
        uid: '123456789',
        name: "Jane",
        token: "ABCabc123",
      },
    });
De esta forma estoy comprobando que se guarda.
NOTA:parece que era necesario traerse todo el módulo.No puedo hacer esto:
import { fetchSinToken } from '../../helpers/fetch';
Hay que traerse todo.
import * as fetchModule from "../../helpers/fetch";

			VIDEO 394 PRUEBAS CON LA ACCIÓN CHECKING

Nota git stash apply aplica el último cambio en la pila de stash(sin embargo no borra el cambio de la pila)puedo borrarlo con git stash drop,pero aún mejor uso git stash pop que hace las dos cosas(aplicar el último cambio y borrar la pila)
Adicionalmente se recomienda dar un nombre usando git stash save "msg" y también se puede usar cualquier posición de la pila,no tengo porque sacar el último,simplemente es una pila(git apply <id> y git drop <id>)

Bien,volviendo a la prueba parece fácil,pero no lo es.Fijate que en la primera hacemos el login,luego tengo acceso al token para la tercera,ya que se ejecutan secuencialmente.
Aún así sigue dando que no hay token en los headers,¿como puede ser?.Bien,pues porque hemos simulado el Storage.prototype.setItem.Podría parecer que si saco el mock y lo meto en el segundo test para el tercero puedo llamar al localStorage.setItem real y tampoco puedo,xd,ya que en Javascript todo pasa por referencia.

La solución es simular el fetchConToken igual que ya hemos hecho.

    fetchModule.fetchConToken = jest.fn(() => ({
      json() {
        return {
          ok: true,
          name: "Jane",
          uid: "123456789",
          token: "asf",
        };
      },
    }));

    await store.dispatch(startChecking());
    const actions = store.getActions();
    console.log(actions);

    expect(actions[0]).toEqual({
      type: types.authLoginSuccess,
      payload: {
        uid: '123456789',
        name: "Jane",
      },
    });

    expect(localStorage.setItem).toHaveBeenCalledTimes(2);
    expect(localStorage.setItem).toHaveBeenCalledWith(
      "token","asf");

Genial,ha sido más fácil de lo que parecía,sólo que hay que saber simular funciones más complejas.

					VIDEO 395 PRUEBAS EN EL UIREDUCER

Realmente va a ser muy sencillo probar este reducer.Simplemente disparo un par de acciones y espero que cambie su state:

  test("Debe de retornar el estado por defecto", () => {
    const state = uiReducer(initialState, {});
    expect(state).toEqual(initialState);
  });

  test("Debe de abrir y cerrar el modal", () => {
    let action = uiOpenModal();
    let state = uiReducer(initialState, action);

    expect(state).toEqual({
      modalOpen: true,
    });

    action = uiCloseModal();
    state = uiReducer(initialState, action);

    expect(state).toEqual({
      modalOpen: false,
    });

  });

					VIDEO 396 PRUEBAS EN EL AUTHREDUCER

IMPORTANTE: si mi aplicación creciera y agregara ua propiedad extra cualquier prueba que use un toEqual({}) y un object literal hardcodeado me va a fallar,pues el objeto creció.Para evitar esto,es mejor usar expect.objectContaining(object) que va a comprobar si simplemente las incluye,pero podría tener más

En vez de usar {} usar expect.objectContaining({}):

    expect(state).toEqual(expect.objectContaining({
      checking: false,
      uid: null,
      name: null,
    }));
  });

NOTA:recuerda que las acciones síncronas del authActions no las exporté,habrá que hardcodearlas simplemente(o las exporto,pero para qué):

  test('el authLogin funciona correctamente', async () => {
    const action = {
      type: types.authLoginSuccess,
      payload: {
        uid: '123',
        name: 'Juan',
      },
    };

    const state = authReducer(initialState, action);

    expect(state).toEqual({
      checking: false,
      uid: '123',
      name: 'Juan',
    });
  });
Comprobar que realmente objectContaining me pasa con un objeto con más propiedades.

			VIDEO 397 PRUEBAS EN EL COMPONENTE DELETEEVENTFAB

Fijate que el componente Calendar viene con un montón de eventos.Fernando me enseñara una forma de disparar eventos de librerias de terceros.El Modal también es otro componente de terceros y el Date Picker igual,asi que será muy interesante aprenderlo.

Volviendo al video,para probar este componente DeleteEventFab va a ser complicado configurar todo para testearlo.La ventaja es que es la misma configuración para los demás.

import React from "react";
import { mount } from "enzyme";
import { DeleteEventFab } from "../../../components/ui/DeleteEventFab";
import { Provider } from "react-redux";

import configureMockStore from "redux-mock-store";
import thunk from "redux-thunk";
import '@testing-library/jest-dom';


const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

const initialState = {}
const store = mockStore(initialState);
store.dispatch = jest.fn();

const wrapper = mount(
  <Provider store={store}>
    <DeleteEventFab />
  </Provider>
);
Realmente es añadir a la configuración que ya estaba usando la necesaria para un Componente que usa el storeS(mount+Provider)

Si miro el componente puedo ver que no necesito un initialState y que lo único que puedo probar es que se llame al startDeleting,no hay más para probar

				VIDEO 398 PRUEBA EN EL DeleteEventFab

Bien,y como puedo probar que efectivamente se llama al  eventStartDeleting?.Porque probar que se llama al dispatch no es del todo correcto:

  test("Debe de llamar al eventStartDelete", () => {
    const button = wrapper.find("button");
    button.simulate("click");
    
    expect(store.dispatch).toHaveBeenCalled();
    expect(store.dispatch).toHaveBeenCalledTimes(1);
    
  });

Hay que hacer un mock completo de la función.Realmente no necesito su lógica,sólo que se llame a ella en concreto.Muy interesante:

jest.mock('../../../actions/eventActions', () => ({
    eventStartDeleting: jest.fn()
    }));

Ya puedo esperar que se haya llamado esta función en concreto:

  expect(store.dispatch).toHaveBeenCalledWith(eventStartDeleting());
  expect(eventStartDeleting).toHaveBeenCalled();

Ahora si que es un prueba completa satisfactoria,no a medias.

			VIDEO 399 PRUEBAS EN EL COMPONENTE APP-ROUTER

NOTA: fijate que tras intentar hacer una snapshot me sale este error:

 react-modal: No elements were found for selector #root.

Esto se debe a que nuestro modal necesita el <div id="root"> pero en un ambiente de pruebas no lo tengo,lógicamente.Yo no quiero probar el modal ahora,ya lo haremos más adelante.Asi que lo que quiero es pasar este error.

Hay varias formas de hacerlo.Una muy poco elegante sería ir al código de desarrollo,a esa línea en ese componente CalendarModal y poner una condición

if( process.env.NODE_ENV !== 'test'){
  Modal.setAppElement('root')
}
Ahora en los tests ya no tendré ese fallo
NOTA:fijate que si no hay Links parece que no se necesita el MemoryRouter

		VIDEO 400 MOSTRAR RUTA DIFERENTE SEGÚN SE ESTÁ AUTENTICADO O NO

Recuerda que la condición era tener o no la propiedad uid para ver una ruta pública o privada:
const PublicRoute = ({ children }) => {
  const { uid } = useSelector((state) => state.auth);
  return !!uid ? <Navigate to="/" /> : children;

 Fijate que para simular que estoy en el login tengo que tener la propiedad uid y y puedo evaluar cualquier cosa del LoginComponent,como que tenga un h1 con el texto xxx,etc.Evaluaremos que exista la clase 'login-container',que es suficiente:

test('Debe de mostrar la ruta pública', () => {
      
  const initialState = {
        auth: {
          checking: false,
          uid:null //no autenticado
         }
      }

 expect(wrapper).toMatchSnapshot();
 expect(wrapper.find("login-container").exists()).toBe(true);

IMPORTANTE: las snapshots las puedo mirar,asi me aseguro que realmente se devuelve el HTML correcto,son más importantes de lo que parece!

NOTA:fijate que en la prueba que simulo estar autenticado y que me lleve al CalendarScreen necesitaría tener los events en el store de redux!.Por eso me da fallo la prueba:
Error: Uncaught [TypeError: Cannot destructure property 'events' of '(0 , _reactRedux.useSelector)(...)' as it is undefined.]
Esta claro que tengo un initialState no válido:

De echo hasta me pidió el modalOpen de 'ui':
   const initialState = {
      auth: {
        checking: false,
        uid: "ABC123", //autenticado
      },
      calendar: {
        events: [],
        activeEvent: null,
      },
      ui:{
        modalOpen: false,
      }
    };
Fijate que si saco la snapshot del CalendarScreen me pedirá actualizarla cada mes,pues cambia.

					VIDEO 401 PRUEBAS EN EL LOGIN SCREEN





