						SECCIONES 23-24-25 MERN CALENDAR

		Temas puntuales de la sección

¿Qué veremos en esta sección?

1- Estructura y diseño de nuestra aplicación de Calendario
2- Uso de componentes de terceros
3- Modals
4- Configuración de Redux
5- CRUD local
6- Preparación de pantallas para futuras secciones
7- Uso de MomentJS
8- Manejo de fechas

Esta sección es el inicio de nuestro MERN, (Mongo Express React Node), luego crearemos nuestro backend y después regresaremos a esta app para conectarla y desplegarla en producción

						VIDEO 308 INICIO PROYECTO

Fijate que desde la versión 6 han corregido el falso Redirect que se hacía en la v4 y v5(pues entregaba un 200).Ahora ya si se redirige desde el server en vez de entregar un html en el front y despues redirigir.
Además han cambiado <Switch> por <Routes> y <Redirect> por <Navigate> pero no lo puedo usar más que englobado en una <Route>:

import {
  BrowserRouter,
  Routes,
  Route,
  Navigate,
} from "react-router-dom";

const AppRouter = () => {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<LoginScreen />} />
        <Route path="/" element={<CalendarScreen />} />
        <Route path="*" element={<Navigate replace to="/" />} />
      </Routes>
    </BrowserRouter>
  )
}
* Puedo poner replace={true} o simplemente replace(es un boolean).

				VIDEO 309 LOGINSCREEN Y NAVBAR

Copiamos el código del login+register del Gist(fijate que debo aprender a hacer estos gist) y adicionalmente creamos una navbar muy simple.
     <button className="btn btn-outline-danger">
        <i className="fas fa-sign-out-alt"></i>
        <span> Salir</span>
      </button>

Fijate que queda muy bonito el icono+botón de salir.

				VIDEO 310 REACT BIG CALENDAR

Vamos a usar una libreria que nos proporcionará ese calendario(hay un par de tipos,otro con drag and drop):
>npm i react-big-calendar moment
Puedo ver su documentación aqui:
https://jquense.github.io/react-big-calendar/examples/index.html

Este calendar no es más que un simple componente que recibirá ciertas props que son obligatorias + las opcionales que se quiera:

import BigCalendar from 'react-big-calendar'
import moment from 'moment'

// Setup the localizer by providing the moment (or globalize) Object
// to the correct localizer.
const localizer = BigCalendar.momentLocalizer(moment) // or globalizeLocalizer

const MyCalendar = props => (
  <div>
    <BigCalendar
      localizer={localizer}
      events={myEventsList}
      startAccessor="start"
      endAccessor="end"
    />
  </div>
)
Fijate que va a usar moment para localizar el browser y el idioma del usuario.
>npm i moment

NOTA: ya no se importa por defecto,se usa destructuring.Además hay que usar un par de estilos extra porque esta con el height a 0(hay que poner la clase rbc-calendar con una altura):

Creo un index.css para estilos globales a la aplicación.

html,body {
  height: 100vh;
  width: 100vw;
}

.calendar-screen { <- esta clase para el div que englobe a <BigCalendar>
  display: flex;
  flex-flow: column;
  height: 100vh;

}

.rbc-calendar {
  height: 100%;
}

En cuanto a un evento debe llevar las props start y end aparte de title,desc (ver doc).
const events = [
  {
    title: 'Cumpleaños del jefe',
    start: moment().toDate(), //lo mismo que un new Date()
    end: moment().add(2, 'hours').toDate(),
    bgcolor: '#fafafa'
  }
]

			VIDEO 311 CONFIGURACIONES ADICIONALES AL CALENDARIO

Puedo cambiar el idioma del display del componente con la propiedad messages:
export const messages = {
  allDay: "Todo el día",
  previous: "<",
  next: ">",
  today: "Hoy",
  month: "Mes",
  week: "Semana",
  day: "Día",
  agenda: "Agenda",
  date: "Fecha",
  time: "Hora",
  event: "Evento",
  noEventsInRange: "No hay eventos en este rango",
  showMore: (total) => `+ Ver más (${total})`,
};
    <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages} <- aqui
      />
Aun me falta cambiar el idioma a moment:
import 'moment/locale/es'
moment.locale('es')

Para cambiar el estilo del evento puedo hacerlo también.Será en la propiedad eventPropGetter que recibe una función que configurará ese nuevo estilo.:

  const eventStyleGetter = (event,start,end,isSelected) => {
    console.log(event,start,end,isSelected);
  }
  
  return (
    <div className="calendar-screen">
      <Navbar />
      <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages}
        eventPropGetter={eventStyleGetter}
      />
En ese console.log veré incluso la propiedad custom que enviamos(bgcolor) aparte de end y start(que son Dates).Más adelante incluso crearemos otra llamada 'notes'.Lo importante es que lo que sea que devuelva esta función serán los estilos a aplicar.

  const eventStyleGetter = (event, start, end, isSelected) => {
    let style = {
      backgroundColor: '#3e9edfcf',
      borderRadius: '10px',
      opacity: 0.8,
      display: 'block',
      color: 'black',
    }
    return {
      style
    }
  }

		VIDEO 312 PERSONALIZAR EL CUADRO Y DISPARAR EVENTOS DEL CALENDARIO

 Vamos a crear un nuevo componente para un evento.Para pasarlo a BigCalendar hay que usar otra propiedad de la libreria llamada components.

      <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages}
        eventPropGetter={eventStyleGetter}
        components={{ event: CalendarEvent }}
      />

Fijate que le he pasado el event(components={{event:component) asi que sólo tengo que sacarlo de las props en ese nuevo componente:
export const CalendarEvent = ({ event }) => {
  const { title, user } = event;
  return (
    <div>
      <span>{title}</span>
      <strong>{user.name}</strong>
    </div>
  )
}
EN cuanto a la funcionalidad la libreria ya viene con propiedades para mandarle mis custom setters para el doble click,one click ,change View,etc

  const [ lastView,setLastView] = useState(localStorage.getItem('lastView') || 'month')
  
  // doble click en un evento de calendario
  const onDoubleClick = (e) => {
    console.log(e) //me devuelve todo el evento
  }

  // onSelect es al clickar en un evento una vez
  const onSelect = (e) => {
    console.log(e) //e me devuelve todo el evento
  }
// al cambiar de vista entre mes|semana|dia|agenda
  const onViewChange = (e) => {
    // console.log(e) // e devuelve week|day|month|agenda
    localStorage.setItem('lastView',e)
  }
Ya que estamos guardamos la vista actual en el localStorage y definimos un estado local que la recupere.Se lo puedo pasar como vista en la prop view
 
     <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages}
        eventPropGetter={eventStyleGetter}
        onDoubleClickEvent={onDoubleClick}
        onSelectEvent={onSelect}
        onView={onViewChange}
        view={lastView}
        components={{ event: CalendarEvent }}
      />

				VIDEO 313 CREANDO UN MODAL SOBRE EL CALENDARIO

Vamos a usar la libreria react-modal la cual es bastante popular.Fijate que nuestro modal va a tener bastante lógica en él.
 >npm i react-modal.

Ahora donde quiera usar este modal lo uso como un HighOrderComponent en el que puedo poner lo que yo quiera dentro de él (un form,una imagen,sólo texto,etc...):
Además le puedo pasar mis estilos.Fijate que necesita algo de configuración(nada complicada) asi que lo mejor es visitar la doc de la librería.

import Modal from 'react-modal';

const customStyles = {
  content: {
    top: '50%',
    left: '50%',
    right: 'auto',
    bottom: 'auto',
    marginRight: '-50%',
    transform: 'translate(-50%, -50%)',
  },
};

* Hay que pasarle el 'appelement',el elemento padre de toda la app??
Modal.setAppElement('#root') <- dado que estoy en React estoy dentro de un <div id='root')
	
Ahora me creo mi componente que llamará a este HOC con lo que quiera:

export const CalendarModal = () => {
  return (
    <div>
       <Modal
        isOpen={true}
        // onAfterOpen={afterOpenModal}
        // onRequestClose={closeModal}
        style={customStyles}
        contentLabel="Example Modal"
      >
        <h1>Hola mundo desde React-Modal</h1>
        <hr />
        <span>ESto es un span cara de pan</span>
      </Modal>
    </div>
  )
}
Lógicamente queda toda la lógica pero isOpen será un useState(boolean),onAfterOpen es para poner efectos como fadeIn y onRequestClose para cuando se cierra.
Vamos a configurar un par de clases en el index.css y pasarselas
      <Modal
        isOpen={isOpen}
        onRequestClose={closeModal}
        style={customStyles}
        closeTimeoutMS={200}
        className="modal"
        overlayClassName="modal-fondo"
      >
Fijate que me permite pasarle una clase('modal' en este caso) para cuando esté viendose el modal y otra para cuando esté oculto(propiedad overlayClassName) además del tiempo para cerrarse(propiedad closeTimeoutMS).
Con un poco más de trabajo podría crear un buen modal,aunque luce bastante bien para un estilo sobrio.

					VIDEO 314 CONTENIDO DEL MODAL

FH me proporciona el formulario del modal en recursos.TAmbién vamos a usar la libreria react date-time picker que ya está testeada:
>npm i react-datetime-picker

NOTA:recuerda preguntar si el trabajo es con clases o con hooks

Fijate que fácil es trabajar con fechas con moment:
// 3:45:50s no quiero esto,quiero horas exactas
const startDate = moment().minutes(0).seconds(0).add(1,'hours')
// con esto será siempre la siguiente hora

Sintaxis moment() me da un nuevo Date,pero lo configuro con minutes(number) | seconds(number) y con add(number,type).Amazing.

NOTA:fijate que puedo declarar lo que necesite fuera(arriba) del functional component.Asi sólo se ejecutará una vez:

// en React o Angular apuntar al selector más alto
Modal.setAppElement('#root');

// 3:45:50s no quiero esto,quiero horas exactas
const startDate = moment().minutes(0).seconds(0).add(1,'hours')
// con esto será siempre la siguiente hora

export const CalendarModal = () => {
* Al declararlo arriba me aseguro que solo se ejecuta una vez.

NOTA: dado que en JS todo pasa por referencia,para evitar modificar la primera variable moment tiene su método propio clone que crea un clon de una fecha :

const now = moment().minutes(0).seconds(0).add(1,'hours')
const nowPlus1= now.clone().add(1,'hours')

NOTA: hay otra libreria react-datetime (sin el picker).Hay que traerse el DatePicker en vez de el DateTimePIcker

			VIDEO 315 OBTENER LA INFORMACIÓN DEL FORMULARIO DEL EVENTO

NOTA:fijate que tengo tanto add como substract
  const yesterday = moment(dateStart).subtract(1, 'day')
  const valid = (current) => {
    return current.isAfter(yesterday);
  };

En cuanto a rescatar el formulario no es nada complicado:

const handleInputChange = ( {target} ) => {
    setFormValues({
      ...formValues,
      [target.name]: target.value,
    });
  }
  

  const handleStartDateChange = (date) => {
    setDateStart(date._d);
    setFormValues({
      ...formValues,
      start: date._d,
    });
  }

  const handleEndDateChange = (date) => {
    setDateEnd(date._d);
    setFormValues({
      ...formValues,
      end: date._d,
    });
  }

  const handleSubmitForm = (e) => {
    e.preventDefault();
    console.log(formValues);
  }

*IMPORTANTE:fijate que la clave de pasarle campos de diferentes tipos estuvo en la inicialización del estado del form:
 const [formValues, setFormValues] = useState({
    title:'Evento',
    notes:'', 
    start:now.toDate(),
    end:nowPlus1.toDate(),
  });
Podria pasarle un file,lo que rescate de un select,... esto es sólo el estado final del form.

				VIDEO 316 VALIDACIONES DEL FORMULARIO

Para comparar fechas es más fácil trabajarlas con moment.Fijate que debería tratar de hacer algun buen tutorial sobre esta libreria:

NOTA: una instancia de moment es un objeto grande,con muchas propiedades:

console.log(momentStart);
console.log(momentEnd);
_d: Mon Nov 29 2021 16:00:00 GMT+0100 (hora estándar de Europa central) {}
_i: Mon Nov 29 2021 16:00:00 GMT+0100 (hora estándar de Europa central) {}
_isAMomentObject: true
_isUTC: false
_isValid: true
_locale: Locale {_calendar: {…}, _longDateFormat: {…}, _invalidDate: 'Fecha inválida', _ordinal: '%dº', _dayOfMonthOrdinalParse: /\d{1,2}º/, …}
_pf: {empty: false, unusedTokens: Array(0), unusedInput: Array(0), overflow: -2, charsLeftOver: 0, …}

Pero si le paso el método toDate() pasa a ser una Date de Javascript:

console.log(momentStart.toDate());
console.log(momentEnd.toDate());
Mon Nov 29 2021 15:00:00 GMT+0100 (hora estándar de Europa central)
Mon Nov 29 2021 16:00:00 GMT+0100 (hora estándar de Europa central)
 
De igual forma puedo usar el método moment(JSDate) para pasar una instancia de Date de JS a una instancia de moment(es como JSOn.parse y JSON.stringify):

const momentStart = moment(start);
const momentEnd = moment(end);

Asi que con estos dos métodos paso de JS a moment y viceversa.Como es mucho más fácil comparar instancias de moment que de Date pasamos start y end a instancias de moment. 

   if (momentStart.isSameOrAfter(momentEnd)) {
      console.log('La fecha inicial debe ser menor que la final')
      return;
    }
* Para comparar tengo isAfter,isBefore,isSameOrAfter,isBeforeOrAfter,...
Lógicamente,el usuario necesita feedback de lo que ha sucedido asi que vamos a usar Sweetalert.
NOTA:nada me impide retornar el Swal.fire,dado que debo hacer un return y un Swal.fire puedo combinarlo:

 if (momentStart.isSameOrAfter(momentEnd)) {
      return Swal.fire({
        title: 'Error',
        text: 'La fecha final debe ser mayor que la inicial',
        icon: 'error',
        confirmButtonText: 'Ok'
      })
Fijate que es lo mismo que Swal.fire() + return,va a salirse y además con el Swal.fire.Perfecto.

Lo mismo podría hacer para evaluar el input para el title del evento,pero como es un input lo podemos hacer con bootstrap en vez de Swal y asi vemos dos formas.
* Habrá que usar otro estado local
const [ titleValid,setTitleValid] = useState(true);
* De nuevo fijate como combino la funcionalidad de un return con un setter:
 if(title.trim().length < 2){
      return setTitleValid(false);
    }
Nada me impide retornar el setter,saliendome de la funcion padre de este if.


			VIDEO 317 INSTALACION Y CONFIGURACION DE REDUX

Si bien podemos usar el Context de React vamos a usar Redux de nuevo.Vamos a instalar redux, react-redux, y thunk(redux-thunk) para asincronia.
>npm i redux react-redux redux-thunk
Creo los folders tipicos(types,actions,reducers,store).Empiezo con los types que es lo más fácil:
export const types = {
  uiOpenModal:'[ui] Open modal',
  uiCloseModal:'[ui] Close modal',
}

El primer reducer de momento es sólo para el modal,muy simple:

const initialState = {
  modalOpen: false,
};

export const uiReducer = (state = initialState, action) => {  
  switch (action.type) {
    case types.uiOpenModal:
      return {
        ...state,
        modalOpen: true,
      };
    case types.uiCloseModal:
      return {
        ...state,
        modalOpen: false,
      };
    default:
      return state;
  }
}

Fijate que Fernando va a crear un file rootReducer para combinar todos los reducers.Es una gran idea ya que realmente es otro reducer(luego está bien ubicado en le folder reducers) y además deja claro lo que hará:

import { combineReducers } from 'redux';
import { uiReducer } from './uiReducer';

export const rootReducer = combineReducers({
  ui: uiReducer,
  // TODO AuthReducer
  // TODO CalendarReducer
});
Usaremos tres en esta app,ya los agregaré.Perfecto,crearé el store.js:

import { createStore, applyMiddleware,compose } from 'redux';
import thunk from 'redux-thunk';
import { rootReducer } from '../reducers/rootReducer';

// si existen las herramientas para redux en mis DevTools las va a configurar,si no pues no hace nada ya que no existen :D
const composeEnhancers = (typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) || compose;

// createStore necesita un reducer como primer arg,logicamente será la combinación de todos ellos.
export const store  = createStore(
  rootReducer,
  composeEnhancers(applyMiddleware(thunk))
)
Fijate que queda mucho más claro para mi esta forma,sacando el rootReducer a otro lado.Por último proveo a mi App de este store en un punto alto:

import { Provider } from "react-redux";
import { store } from "./store/store";

import AppRouter from "./routers/AppRouter"

const CalendarApp = () => {
  return (
    <Provider store={store}>
      <AppRouter />
    </Provider>
  )
}
Como puedo ver es realmente sencillo usar redux.

			VIDEO 318 MOSTRAR Y OCULTAR MODAL EN BASE AL STORE

Fijate que se me olvidaron las actions,son importantes porque me permiten meter en una función cuanta funcionalidad desee para una acción:

* en vez de poner el tipo,el payload,etc en el dispatch...
 dispatch({type:types.uiOpenModal}) <- en vez de disparar esto
* simplemente llamo a una acción.Ya desarrollaré la lógica en ella
 dispatch(uiOpenModal())

En las actions si que desarrollo cualquier lógica necesaria:

export const uiOpenModal = () => ({
  type: types.uiOpenModal,
});

export const uiCloseModal = () => ({
  type: types.uiCloseModal,
});
Puedo observar que realmente son necesarias,en cuanto haya un poco de lógica las actions son 100% necesarias.

NOTA: el equipo de Redux creó una librería que reduce la cantidad de código necesario y la complejidad de Redux(esta librería es Redux-toolkit).Es la que usa lama

		VIDEO 319 CALENDARREDUCER Y PRIMERAS ACCIONES CON LOS EVENTOS

De momento creamos dos nuevos tipos y acciones:

export const setActiveEvent = (event) => ({
  type: types.eventSetActive,
  payload: event
})

export const eventAddNew = (event) => ({
  type: types.eventAddNew,
  payload: event
})
En el click del evento simplemente llamamos a la action setActiveEvent

Adicionalmente vamos a crear un fab(floating action button) que abra el modal también.No puede ser más fácil:

export const AddNewFab = () => {
  const dispatch = useDispatch()

  const openModal = () => {
    dispatch(uiOpenModal())
  }

  return (
    <button className="btn btn-primary fab"
    onClick={openModal}>
      <i className="fas fa-plus"></i>
    </button>
  )
}
En los estilos lo pongo en fixed y right y bottom a 25px siempre va a quedar alli.Como icono tenia el +,le subo un poco la fuente le doy un padding y border-radius a 50%.

					VIDEO 320 AÑADIR UN NUEVO EVENTO

Realmente faltan muchas cosas como guardar este nuevo evento en una DB ,pero ya podemos hacerlo en local con redux:
  case types.eventAddNew:
      return {
        ...state,
        events: [...state.events, action.payload],
      };

NOTA: Fernando recomienda siempre pasar una copia cuando se trate de un objeto.
En el dispatch de esta acción le mandaremos varias cosas que aún no tenemos pero lucirá asi un new Event:
    dispatch(eventAddNew({
      ...formValues,
      id: new Date().getTime(),
      user:{
        _id: '123',
        name: 'Juan',
      }
    }));

				VIDEO 321 MOSTRAR EVENTOS EN EL CALENDARIO

Realmente solo hay que usar useSelector(state => state.calendar.events) para mostrarlos.
NOTA: Fijate que al cerrar el modal tengo que resetear el form a un valor por defecto.Ese initialState es mejor declararlo fuera del componente:
  const closeModal = () => {
    dispatch(uiCloseModal());
    setFormValues(initEvent); <- initEvent es mejor sacarlo fuera del componente,para que sólo se cree una vez en vez de tropecientas(aunque se crearían con el mismo valor,estoy creando instancias)Grande Fernando.
	
Por último quiero que al hacer un single click se carge en el formulario el activeEvent.Es más sencillo de lo que parece.Solo hay que usar un efecto que se re-disparará cada vez que cambie el activeEvent.En cuanto no sea null debo cargar el form con estos values:
const { activeEvent} = useSelector(state => state.calendar);

  /* NOTA puedo comprobar por si no es null en un efecto.Incluso por si no es undefined.Lógicamente llevará esa propiedad como dependencia */
  useEffect(() => {
    if(activeEvent){
      setFormValues(activeEvent)
    }
  },[activeEvent]);
En cuanto ese objeto que estoy vigilando no sea null o undefined disparará el códdigo del if.Amazing.

Fijate que tenemos un pequeño fallo ya que el modal limpia el formulario pero deja la nota activa.Hay que ponerla a null para que cambie y dispare el efecto:

  case types.eventClearActiveEvent:
      return {
        ...state,
        activeEvent: null,
      };

				VIDEO 322 EDITAR EL EVENTO ACTIVO

Fijate que lo mejor es iterar con un map y aplicar un ternario o un filter para actualizar en redux:

    case types.eventUpdate:
      return {
        ...state,
        events: state.events.map((event) =>
          event.id === action.payload.id 
            ? action.payload 
            : event
        ),
      };
Obviamente hay que crear el type y la action,pero son muy sencillas.Lo más complicado será saber cuando hay que llamar al actualizar y cuando al new.Para esto vamos a usar la existencia del campo id como condición.

*Si el activeEvent está en null estoy creando uno,si está definido estoy editando
    if (activeEvent) {
      dispatch(eventUpdate(formValues))
    } else {
      dispatch(eventAddNew({
        ...formValues,
        id: new Date().getTime(),
        user: {
          _id: '123',
          name: 'Juan',
        }
      }));
    }

					VIDEO 323 ELIMINAR EVENTO

Realmente va a ser muy sencillo,ya que vamos a borrar la nota activa.Si no hay ninguna nota activa no aparecerá el botón de borrar.
NOTA:para ir del tmux al ide son dos clicks.Para ir del tmux o ide al navegador es uno.Debo recordar cual es mi última posición,si el tmux o el ide.

Fijate que la action no va a recibir un payload:
  case types.eventDelete:
      return {
        ...state,
        events: state.events.filter(
          event => event.id !== state.activeEvent.id),
        activeEvent: null,
      };
El botón se mostrará condicionalmente:

export const DeleteEventFab = () => {
  return (
    <button className="btn btn-danger fab-danger">
      <i className="fas fa-trash"></i>
      <span>Borrar evento</span>
    </button>
  )
}

Fijate que puedo pasar cualquier valor a booleano:
{ !!activeEvent && <DeleteEventFab /> }
Aunque ya se iba a resolver si no esta undefined a true.

NOTA: esta libreria react-big-calendar trae muchas funciones.Hay una muy interesante que es onSelectSlot(la cual requiere de la propiedad selectable={true}).Cuando haga click en una slot me dará información sobre esa ranura.
Fijate que podría usarla para introducir las fechas automáticamente,ya que me va a dar siempre las fechas de inicio y fin de esa ranura
En la siguiente sección crearemos un backend funcional.

					SECCION 24 CALENDAR APP BACKEND

¿Qué veremos en esta sección?

1- Node Express Mongoose Modelos 
2- Controllers
3- Middlewares de Express
4- JWT
5- Autenticación pasiva
6- Payloads
7-  Encriptación
8- Rutas
9- CORS
10- Revalidar tokens
11- MongoDB & MongoAtlas & MongoCompass

Es una sección bastante pesada en el aspecto de que no es React lo que veremos, pero todo lo haremos con JavaScript, y ya debemos de estar familiarizados con él.

El backend que haremos aquí es robusto y lo podrían utilizar en proyectos reales, espero que lo aprovechen y sobre todo aprendan bastante.

Si quieren saber más sobre Node, recuerden que tengo un curso especializado en ese tema.

				VIDEO 328 CALENDAR APP BACKEND - INICIO

NOTA: express está por sacar la versión 5.Esto podría dar problemas.Recuerda que puedo instalar una versión en concreto con npm i paquete@version:

>npm i express@4.17.1 <- la que está en este momento vigente

Fijate que en NOde sólo se usa el .env,a diferencia de en el front que puedo y debo usar varios tipos de .env

Vamos a crear un directorio público donde serviremos nuestra aplicación Angular.
app.use(express.static('public').
Recuerda que puedo usar varias approach:
app.use("/",express.static(path.join(__dirname,'public');
app.use(express.static(path.join(__dirname, './public')));

Siempre que apunte bien a la carpeta puedo usar la que quiera

NOTA:recuerda que  no puedo responder dos veces en un controlador.Me dará el error ERR_HTTP_HEADERS_SENT.Cannot set headers after they are sent.ESto es por haber usado dos res.json o res.sendFile + res.json | res.send | res.download.

Por ejemplo este código puede disparar esto:
exports.crearUsuario = (req = request, res = response) => {
  const { name, email, password } = req.body;

  if(name.length <= 5) {
    res.status(400).json({
      ok: false,
      msg: 'El nombre debe tener al menos 5 caracteres'
    });

  res.json({
    ok: true,
  });
};
La solución es terminar con un return res.json,por ejemplo.

					VIDEO 334 EXPRESS-VALIDATOR

NOTA:fijate que isEmail() ya me comprueba que venga algo(pues si no viene nada no es un email.Como siempre lo mejor es crear un customMiddleware para no ir de controlador en controlador imprimiendo los errores:

const { request, response } = require('express');
const { validationResult } = require('express-validator');

const validarCampos = (req=request, res=response, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      ok: false,
      errors: errors.mapped()
    });
  }
};

module.exports = {
  validarCampos
 };

			VIDEO 336 CONFIGURACION DE LA BASE DE DATOS MONGO-ATLAS

Realmente es muy sencillo ya en la version 6.Recuerda que es mejor crear una carppeta para gestionar las conexiones a DBs.

const dbConnection = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("MongoDB Connected to: " + mongoose.connection.name);
  } catch (error) {
    console.log(error);
  }
};
module.exports = { dbConnection };

				VIDEO 338 CREAR UN USUARIO EN LA DB REMOTA

NOTA:fijate que en express-validator puedo agregar custom validations que hagan peticiones:

  check('email', 'El email es obligatorio').isEmail()
     .custom(async value => {
        const emailCheck = await getUserByEmail(value);
        if (!!emailCheck) 
           return Promise.reject();  <- con el reject lo veo por consolo con un throw new Error no lo veo por consola ni cae la app.Cuestión de gustos.
        }).withMessage('Email ya se encuentra registrado'),

De esta forma lo compruebo desde el middleware,que se ejecuta justo antes del controlador.Sea como sea uno de los dos tendrá que mirar por si existe el email y hacer una petición.

				VIDEO 339 ENCRIPTAR LA CONTRASEÑA

No va a ser posible recuperar una contraseña que se encripte con un hash de una sola vía.NO es nada complicado,ya existe la libreria bcryptjs(escrita en JS) y bcrypt(escrita en C++,por lo que es más rápida) que se encarga de todo:
>npm i bcrypt | bcryptjs
NOTA:parece mejor opción instalar bcrypts por ser un 20-30% mas rápida.
 
const bcrypt = require("bcrypt")
const salt = bcrypt.genSaltSync(10) <- por defecto es 10 también
usuario.password = bcrypt.hashSync(password, 10);

Fijate que usamos todo sincrono,aunque podemos usar promesas.Hay una recomendación al respecto:
Why is async mode recommended over sync mode?
If you are using bcrypt on a simple script, using the sync mode is perfectly fine. However, if you are using bcrypt on a server, the async mode is recommended. This is because the hashing done by bcrypt is CPU intensive, so the sync version will block the event loop and prevent your application from servicing any other inbound requests or events. The async version uses a thread pool which does not block the main event loop.
Si es para un server mejor asincrono para que libere el event loop.

					VIDEO 341 LOGIN DE USUARIO

Ya tenemos la manera de encriptar una password,ahora necesitamos una forma para comprobarlas.Dado que estamos con un hash de una sola via,el método compare realmente va a comprobar si haría match la contraseña en texto plano tras encriptarla con la ya encriptada.

bcrypt.compareSync(password, usuario.password); <- recuerda que estamos haciendo todo síncrono

				VIDEO 342 GENERAR UN JSON WEB TOKEN

Queremos autenticar tanto en el register como en el login.Permiten manejar el estado de la sesión del usuario de forma pasiva.
Un token tiene tres partes,header,body y signature.
El header especifica el algoritmo de encriptación y el tipo(un json web token en nuestro caso,hay varios tipos de token).
El body contiene el payload(no se guarda información sensible).
Fijate que exponer un id no es nada importante
En la firma del token habrá una palabra secreta para comprobar que el server pueda comprobar que el token que viene del frontend es válido.

NOTA:con lo anterior en mente fijate la importancia de crear una signature fuerte,porque si la cogen pueden firmar tokens válidos:
JWT_SECRET=merncalendarappwithreduxandjwt <- supongo que simbolos y números aún mejor

En cuanto a la libreria jsonwebtoken aún no trabaja con promesas,asi que hay que hacer un pequeño apaño:

const generarJWT = (uid,name) => {
    return new Promise((resolve, reject) => {
        const payload = { uid,name };

        jwt.sign(payload, process.env.JWT_SECRET, {
            expiresIn: '2h'
        }, (err, token) => {
            if (err) {
                reject('Error generando el token');
            } else {
                resolve(token);
            }
        });
    });
} 
Como argumentos los que yo quiera.

						VIDEO 343 REVALIDAR TOKEN 

Si quiero revalidar un token tengo que asegurarme,claro está,que el primer token sea válido(id del usuario,exp válido).

El objetivo es seguir generando tokens válidos mientras el usuario siga usando la aplicación.Lo que haremos será crear un endpoint al que si se llama devuelve otro jwt que sustituye el jwt actual.

Usualmente es un standar que cuando cree un header personalizado le dé un nombre que empieza por x-, asi que usaremos x-token para mandar el token en el header.

Para rescatarlo puedo usar req.header('x-token') o req.headers['x-token'];

exports.validarJWT = (req, res= response, next) => {
    const token = req.headers['x-token'];

     if (token) {
        jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {
            if (err) {
                return res.status(401).json({
                    ok: false,
                    mensaje: 'Token proveido no válido',
                    errors: err
                });
            }
            req.uid = decoded.uid;
            req.name = decoded.name;
            next();
        });
    } else {
        return res.status(401).json({
            ok: false,
            mensaje: 'Token no proveído',
            errors: { message: 'No token provided' }
        });
    }
}

NOTA: si la integridad de la aplicación fuera comprometida cambiar el SECRET para la signature inhabilitaría todos los tokens existentes.

			VIDEO 345 CONFIGURAR CORS

Dado que esto será una API,una aplicación de programación a la cual cualquier persona del mundo podrá hacer peticiones.
Con el CORS puedo configurar esto(podría restringir dominios,IPs,...)
NO es infalible,pero añade una capa de seguridad.
Incluso puedo habilitar las CORS sólo para un endpoint.Sin embargo haremos una configuración básica del CORS.

const cors = require('cors')
app.use(cors()) 

No hay mucho más que configurar por ahora.Recuerda que POSTMAN engaña al backend haciendo creer que la petición ha salido del mismo servidor cuando no es así.

				SECCION 25 BACKEND-EVENTOS DEL CALENDARIO

¿Qué veremos en esta sección?

1- CRUD completo de eventos de calendario
2- Modelos
3- Validaciones automáticas
4- Validaciones personalizadas

Aquí trabajaremos creando todo lo necesario para que podamos insertar, actualiza y eliminar información relacionada a los eventos que nuestra aplicación del calendario necesitará.

					VIDEO 348 CONTINUACION PROYECTO


