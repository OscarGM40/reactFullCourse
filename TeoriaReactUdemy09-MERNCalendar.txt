						SECCIONES 23-24-25 MERN CALENDAR

		Temas puntuales de la sección

¿Qué veremos en esta sección?

1- Estructura y diseño de nuestra aplicación de Calendario
2- Uso de componentes de terceros
3- Modals
4- Configuración de Redux
5- CRUD local
6- Preparación de pantallas para futuras secciones
7- Uso de MomentJS
8- Manejo de fechas

Esta sección es el inicio de nuestro MERN, (Mongo Express React Node), luego crearemos nuestro backend y después regresaremos a esta app para conectarla y desplegarla en producción

						VIDEO 308 INICIO PROYECTO

Fijate que desde la versión 6 han corregido el falso Redirect que se hacía en la v4 y v5(pues entregaba un 200).Ahora ya si se redirige desde el server en vez de entregar un html en el front y despues redirigir.
Además han cambiado <Switch> por <Routes> y <Redirect> por <Navigate> pero no lo puedo usar más que englobado en una <Route>:

import {
  BrowserRouter,
  Routes,
  Route,
  Navigate,
} from "react-router-dom";

const AppRouter = () => {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<LoginScreen />} />
        <Route path="/" element={<CalendarScreen />} />
        <Route path="*" element={<Navigate replace to="/" />} />
      </Routes>
    </BrowserRouter>
  )
}
* Puedo poner replace={true} o simplemente replace(es un boolean).

				VIDEO 309 LOGINSCREEN Y NAVBAR

Copiamos el código del login+register del Gist(fijate que debo aprender a hacer estos gist) y adicionalmente creamos una navbar muy simple.
     <button className="btn btn-outline-danger">
        <i className="fas fa-sign-out-alt"></i>
        <span> Salir</span>
      </button>

Fijate que queda muy bonito el icono+botón de salir.

				VIDEO 310 REACT BIG CALENDAR

Vamos a usar una libreria que nos proporcionará ese calendario(hay un par de tipos,otro con drag and drop):
>npm i react-big-calendar moment
Puedo ver su documentación aqui:
https://jquense.github.io/react-big-calendar/examples/index.html

Este calendar no es más que un simple componente que recibirá ciertas props que son obligatorias + las opcionales que se quiera:

import BigCalendar from 'react-big-calendar'
import moment from 'moment'

// Setup the localizer by providing the moment (or globalize) Object
// to the correct localizer.
const localizer = BigCalendar.momentLocalizer(moment) // or globalizeLocalizer

const MyCalendar = props => (
  <div>
    <BigCalendar
      localizer={localizer}
      events={myEventsList}
      startAccessor="start"
      endAccessor="end"
    />
  </div>
)
Fijate que va a usar moment para localizar el browser y el idioma del usuario.
>npm i moment

NOTA: ya no se importa por defecto,se usa destructuring.Además hay que usar un par de estilos extra porque esta con el height a 0(hay que poner la clase rbc-calendar con una altura):

Creo un index.css para estilos globales a la aplicación.

html,body {
  height: 100vh;
  width: 100vw;
}

.calendar-screen { <- esta clase para el div que englobe a <BigCalendar>
  display: flex;
  flex-flow: column;
  height: 100vh;

}

.rbc-calendar {
  height: 100%;
}

En cuanto a un evento debe llevar las props start y end aparte de title,desc (ver doc).
const events = [
  {
    title: 'Cumpleaños del jefe',
    start: moment().toDate(), //lo mismo que un new Date()
    end: moment().add(2, 'hours').toDate(),
    bgcolor: '#fafafa'
  }
]

			VIDEO 311 CONFIGURACIONES ADICIONALES AL CALENDARIO

Puedo cambiar el idioma del display del componente con la propiedad messages:
export const messages = {
  allDay: "Todo el día",
  previous: "<",
  next: ">",
  today: "Hoy",
  month: "Mes",
  week: "Semana",
  day: "Día",
  agenda: "Agenda",
  date: "Fecha",
  time: "Hora",
  event: "Evento",
  noEventsInRange: "No hay eventos en este rango",
  showMore: (total) => `+ Ver más (${total})`,
};
    <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages} <- aqui
      />
Aun me falta cambiar el idioma a moment:
import 'moment/locale/es'
moment.locale('es')

Para cambiar el estilo del evento puedo hacerlo también.Será en la propiedad eventPropGetter que recibe una función que configurará ese nuevo estilo.:

  const eventStyleGetter = (event,start,end,isSelected) => {
    console.log(event,start,end,isSelected);
  }
  
  return (
    <div className="calendar-screen">
      <Navbar />
      <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages}
        eventPropGetter={eventStyleGetter}
      />
En ese console.log veré incluso la propiedad custom que enviamos(bgcolor) aparte de end y start(que son Dates).Más adelante incluso crearemos otra llamada 'notes'.Lo importante es que lo que sea que devuelva esta función serán los estilos a aplicar.

  const eventStyleGetter = (event, start, end, isSelected) => {
    let style = {
      backgroundColor: '#3e9edfcf',
      borderRadius: '10px',
      opacity: 0.8,
      display: 'block',
      color: 'black',
    }
    return {
      style
    }
  }

		VIDEO 312 PERSONALIZAR EL CUADRO Y DISPARAR EVENTOS DEL CALENDARIO

 Vamos a crear un nuevo componente para un evento.Para pasarlo a BigCalendar hay que usar otra propiedad de la libreria llamada components.

      <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages}
        eventPropGetter={eventStyleGetter}
        components={{ event: CalendarEvent }}
      />

Fijate que le he pasado el event(components={{event:component) asi que sólo tengo que sacarlo de las props en ese nuevo componente:
export const CalendarEvent = ({ event }) => {
  const { title, user } = event;
  return (
    <div>
      <span>{title}</span>
      <strong>{user.name}</strong>
    </div>
  )
}
EN cuanto a la funcionalidad la libreria ya viene con propiedades para mandarle mis custom setters para el doble click,one click ,change View,etc

  const [ lastView,setLastView] = useState(localStorage.getItem('lastView') || 'month')
  
  // doble click en un evento de calendario
  const onDoubleClick = (e) => {
    console.log(e) //me devuelve todo el evento
  }

  // onSelect es al clickar en un evento una vez
  const onSelect = (e) => {
    console.log(e) //e me devuelve todo el evento
  }
// al cambiar de vista entre mes|semana|dia|agenda
  const onViewChange = (e) => {
    // console.log(e) // e devuelve week|day|month|agenda
    localStorage.setItem('lastView',e)
  }
Ya que estamos guardamos la vista actual en el localStorage y definimos un estado local que la recupere.Se lo puedo pasar como vista en la prop view
 
     <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages}
        eventPropGetter={eventStyleGetter}
        onDoubleClickEvent={onDoubleClick}
        onSelectEvent={onSelect}
        onView={onViewChange}
        view={lastView}
        components={{ event: CalendarEvent }}
      />

				VIDEO 313 CREANDO UN MODAL SOBRE EL CALENDARIO

Vamos a usar la libreria react-modal la cual es bastante popular.Fijate que nuestro modal va a tener bastante lógica en él.
 >npm i react-modal.

Ahora donde quiera usar este modal lo uso como un HighOrderComponent en el que puedo poner lo que yo quiera dentro de él (un form,una imagen,sólo texto,etc...):
Además le puedo pasar mis estilos.Fijate que necesita algo de configuración(nada complicada) asi que lo mejor es visitar la doc de la librería.

import Modal from 'react-modal';

const customStyles = {
  content: {
    top: '50%',
    left: '50%',
    right: 'auto',
    bottom: 'auto',
    marginRight: '-50%',
    transform: 'translate(-50%, -50%)',
  },
};

* Hay que pasarle el 'appelement',el elemento padre de toda la app??
Modal.setAppElement('#root') <- dado que estoy en React estoy dentro de un <div id='root')
	
Ahora me creo mi componente que llamará a este HOC con lo que quiera:

export const CalendarModal = () => {
  return (
    <div>
       <Modal
        isOpen={true}
        // onAfterOpen={afterOpenModal}
        // onRequestClose={closeModal}
        style={customStyles}
        contentLabel="Example Modal"
      >
        <h1>Hola mundo desde React-Modal</h1>
        <hr />
        <span>ESto es un span cara de pan</span>
      </Modal>
    </div>
  )
}
Lógicamente queda toda la lógica pero isOpen será un useState(boolean),onAfterOpen es para poner efectos como fadeIn y onRequestClose para cuando se cierra.
Vamos a configurar un par de clases en el index.css y pasarselas
      <Modal
        isOpen={isOpen}
        onRequestClose={closeModal}
        style={customStyles}
        closeTimeoutMS={200}
        className="modal"
        overlayClassName="modal-fondo"
      >
Fijate que me permite pasarle una clase('modal' en este caso) para cuando esté viendose el modal y otra para cuando esté oculto(propiedad overlayClassName) además del tiempo para cerrarse(propiedad closeTimeoutMS).
Con un poco más de trabajo podría crear un buen modal,aunque luce bastante bien para un estilo sobrio.

					VIDEO 314 CONTENIDO DEL MODAL

FH me proporciona el formulario del modal en recursos.TAmbién vamos a usar la libreria react date-time picker que ya está testeada:
>npm i react-datetime-picker

NOTA:recuerda preguntar si el trabajo es con clases o con hooks

Fijate que fácil es trabajar con fechas con moment:
// 3:45:50s no quiero esto,quiero horas exactas
const startDate = moment().minutes(0).seconds(0).add(1,'hours')
// con esto será siempre la siguiente hora

Sintaxis moment() me da un nuevo Date,pero lo configuro con minutes(number) | seconds(number) y con add(number,type).Amazing.

NOTA:fijate que puedo declarar lo que necesite fuera(arriba) del functional component.Asi sólo se ejecutará una vez:

// en React o Angular apuntar al selector más alto
Modal.setAppElement('#root');

// 3:45:50s no quiero esto,quiero horas exactas
const startDate = moment().minutes(0).seconds(0).add(1,'hours')
// con esto será siempre la siguiente hora

export const CalendarModal = () => {
* Al declararlo arriba me aseguro que solo se ejecuta una vez.

NOTA: dado que en JS todo pasa por referencia,para evitar modificar la primera variable moment tiene su método propio clone que crea un clon de una fecha :

const now = moment().minutes(0).seconds(0).add(1,'hours')
const nowPlus1= now.clone().add(1,'hours')

NOTA: hay otra libreria react-datetime (sin el picker).Hay que traerse el DatePicker en vez de el DateTimePIcker

			VIDEO 315 OBTENER LA INFORMACIÓN DEL FORMULARIO DEL EVENTO

NOTA:fijate que tengo tanto add como substract
  const yesterday = moment(dateStart).subtract(1, 'day')
  const valid = (current) => {
    return current.isAfter(yesterday);
  };

En cuanto a rescatar el formulario no es nada complicado:

const handleInputChange = ( {target} ) => {
    setFormValues({
      ...formValues,
      [target.name]: target.value,
    });
  }
  

  const handleStartDateChange = (date) => {
    setDateStart(date._d);
    setFormValues({
      ...formValues,
      start: date._d,
    });
  }

  const handleEndDateChange = (date) => {
    setDateEnd(date._d);
    setFormValues({
      ...formValues,
      end: date._d,
    });
  }

  const handleSubmitForm = (e) => {
    e.preventDefault();
    console.log(formValues);
  }

*IMPORTANTE:fijate que la clave de pasarle campos de diferentes tipos estuvo en la inicialización del estado del form:
 const [formValues, setFormValues] = useState({
    title:'Evento',
    notes:'', 
    start:now.toDate(),
    end:nowPlus1.toDate(),
  });
Podria pasarle un file,lo que rescate de un select,... esto es sólo el estado final del form.

				VIDEO 316 VALIDACIONES DEL FORMULARIO


