						SECCIONES 23-24-25 MERN CALENDAR

		Temas puntuales de la sección

¿Qué veremos en esta sección?

1- Estructura y diseño de nuestra aplicación de Calendario
2- Uso de componentes de terceros
3- Modals
4- Configuración de Redux
5- CRUD local
6- Preparación de pantallas para futuras secciones
7- Uso de MomentJS
8- Manejo de fechas

Esta sección es el inicio de nuestro MERN, (Mongo Express React Node), luego crearemos nuestro backend y después regresaremos a esta app para conectarla y desplegarla en producción

						VIDEO 308 INICIO PROYECTO

Fijate que desde la versión 6 han corregido el falso Redirect que se hacía en la v4 y v5(pues entregaba un 200).Ahora ya si se redirige desde el server en vez de entregar un html en el front y despues redirigir.
Además han cambiado <Switch> por <Routes> y <Redirect> por <Navigate> pero no lo puedo usar más que englobado en una <Route>:

import {
  BrowserRouter,
  Routes,
  Route,
  Navigate,
} from "react-router-dom";

const AppRouter = () => {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<LoginScreen />} />
        <Route path="/" element={<CalendarScreen />} />
        <Route path="*" element={<Navigate replace to="/" />} />
      </Routes>
    </BrowserRouter>
  )
}
* Puedo poner replace={true} o simplemente replace(es un boolean).

				VIDEO 309 LOGINSCREEN Y NAVBAR

Copiamos el código del login+register del Gist(fijate que debo aprender a hacer estos gist) y adicionalmente creamos una navbar muy simple.
     <button className="btn btn-outline-danger">
        <i className="fas fa-sign-out-alt"></i>
        <span> Salir</span>
      </button>

Fijate que queda muy bonito el icono+botón de salir.

				VIDEO 310 REACT BIG CALENDAR

Vamos a usar una libreria que nos proporcionará ese calendario(hay un par de tipos,otro con drag and drop):
>npm i react-big-calendar moment
Puedo ver su documentación aqui:
https://jquense.github.io/react-big-calendar/examples/index.html

Este calendar no es más que un simple componente que recibirá ciertas props que son obligatorias + las opcionales que se quiera:

import BigCalendar from 'react-big-calendar'
import moment from 'moment'

// Setup the localizer by providing the moment (or globalize) Object
// to the correct localizer.
const localizer = BigCalendar.momentLocalizer(moment) // or globalizeLocalizer

const MyCalendar = props => (
  <div>
    <BigCalendar
      localizer={localizer}
      events={myEventsList}
      startAccessor="start"
      endAccessor="end"
    />
  </div>
)
Fijate que va a usar moment para localizar el browser y el idioma del usuario.
>npm i moment

NOTA: ya no se importa por defecto,se usa destructuring.Además hay que usar un par de estilos extra porque esta con el height a 0(hay que poner la clase rbc-calendar con una altura):

Creo un index.css para estilos globales a la aplicación.

html,body {
  height: 100vh;
  width: 100vw;
}

.calendar-screen { <- esta clase para el div que englobe a <BigCalendar>
  display: flex;
  flex-flow: column;
  height: 100vh;

}

.rbc-calendar {
  height: 100%;
}

En cuanto a un evento debe llevar las props start y end aparte de title,desc (ver doc).
const events = [
  {
    title: 'Cumpleaños del jefe',
    start: moment().toDate(), //lo mismo que un new Date()
    end: moment().add(2, 'hours').toDate(),
    bgcolor: '#fafafa'
  }
]

			VIDEO 311 CONFIGURACIONES ADICIONALES AL CALENDARIO

Puedo cambiar el idioma del display del componente con la propiedad messages:
export const messages = {
  allDay: "Todo el día",
  previous: "<",
  next: ">",
  today: "Hoy",
  month: "Mes",
  week: "Semana",
  day: "Día",
  agenda: "Agenda",
  date: "Fecha",
  time: "Hora",
  event: "Evento",
  noEventsInRange: "No hay eventos en este rango",
  showMore: (total) => `+ Ver más (${total})`,
};
    <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages} <- aqui
      />
Aun me falta cambiar el idioma a moment:
import 'moment/locale/es'
moment.locale('es')

Para cambiar el estilo del evento puedo hacerlo también.Será en la propiedad eventPropGetter que recibe una función que configurará ese nuevo estilo.:

  const eventStyleGetter = (event,start,end,isSelected) => {
    console.log(event,start,end,isSelected);
  }
  
  return (
    <div className="calendar-screen">
      <Navbar />
      <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages}
        eventPropGetter={eventStyleGetter}
      />
En ese console.log veré incluso la propiedad custom que enviamos(bgcolor) aparte de end y start(que son Dates).Más adelante incluso crearemos otra llamada 'notes'.Lo importante es que lo que sea que devuelva esta función serán los estilos a aplicar.

  const eventStyleGetter = (event, start, end, isSelected) => {
    let style = {
      backgroundColor: '#3e9edfcf',
      borderRadius: '10px',
      opacity: 0.8,
      display: 'block',
      color: 'black',
    }
    return {
      style
    }
  }

		VIDEO 312 PERSONALIZAR EL CUADRO Y DISPARAR EVENTOS DEL CALENDARIO

 Vamos a crear un nuevo componente para un evento.Para pasarlo a BigCalendar hay que usar otra propiedad de la libreria llamada components.

      <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages}
        eventPropGetter={eventStyleGetter}
        components={{ event: CalendarEvent }}
      />

Fijate que le he pasado el event(components={{event:component) asi que sólo tengo que sacarlo de las props en ese nuevo componente:
export const CalendarEvent = ({ event }) => {
  const { title, user } = event;
  return (
    <div>
      <span>{title}</span>
      <strong>{user.name}</strong>
    </div>
  )
}
EN cuanto a la funcionalidad la libreria ya viene con propiedades para mandarle mis custom setters para el doble click,one click ,change View,etc

  const [ lastView,setLastView] = useState(localStorage.getItem('lastView') || 'month')
  
  // doble click en un evento de calendario
  const onDoubleClick = (e) => {
    console.log(e) //me devuelve todo el evento
  }

  // onSelect es al clickar en un evento una vez
  const onSelect = (e) => {
    console.log(e) //e me devuelve todo el evento
  }
// al cambiar de vista entre mes|semana|dia|agenda
  const onViewChange = (e) => {
    // console.log(e) // e devuelve week|day|month|agenda
    localStorage.setItem('lastView',e)
  }
Ya que estamos guardamos la vista actual en el localStorage y definimos un estado local que la recupere.Se lo puedo pasar como vista en la prop view
 
     <BigCalendar
        localizer={localizer}
        events={events}
        startAccessor="start"
        endAccessor="end"
        messages={messages}
        eventPropGetter={eventStyleGetter}
        onDoubleClickEvent={onDoubleClick}
        onSelectEvent={onSelect}
        onView={onViewChange}
        view={lastView}
        components={{ event: CalendarEvent }}
      />

				VIDEO 313 CREANDO UN MODAL SOBRE EL CALENDARIO

Vamos a usar la libreria react-modal la cual es bastante popular.Fijate que nuestro modal va a tener bastante lógica en él.
 >npm i react-modal.

Ahora donde quiera usar este modal lo uso como un HighOrderComponent en el que puedo poner lo que yo quiera dentro de él (un form,una imagen,sólo texto,etc...):
Además le puedo pasar mis estilos.Fijate que necesita algo de configuración(nada complicada) asi que lo mejor es visitar la doc de la librería.

import Modal from 'react-modal';

const customStyles = {
  content: {
    top: '50%',
    left: '50%',
    right: 'auto',
    bottom: 'auto',
    marginRight: '-50%',
    transform: 'translate(-50%, -50%)',
  },
};

* Hay que pasarle el 'appelement',el elemento padre de toda la app??
Modal.setAppElement('#root') <- dado que estoy en React estoy dentro de un <div id='root')
	
Ahora me creo mi componente que llamará a este HOC con lo que quiera:

export const CalendarModal = () => {
  return (
    <div>
       <Modal
        isOpen={true}
        // onAfterOpen={afterOpenModal}
        // onRequestClose={closeModal}
        style={customStyles}
        contentLabel="Example Modal"
      >
        <h1>Hola mundo desde React-Modal</h1>
        <hr />
        <span>ESto es un span cara de pan</span>
      </Modal>
    </div>
  )
}
Lógicamente queda toda la lógica pero isOpen será un useState(boolean),onAfterOpen es para poner efectos como fadeIn y onRequestClose para cuando se cierra.
Vamos a configurar un par de clases en el index.css y pasarselas
      <Modal
        isOpen={isOpen}
        onRequestClose={closeModal}
        style={customStyles}
        closeTimeoutMS={200}
        className="modal"
        overlayClassName="modal-fondo"
      >
Fijate que me permite pasarle una clase('modal' en este caso) para cuando esté viendose el modal y otra para cuando esté oculto(propiedad overlayClassName) además del tiempo para cerrarse(propiedad closeTimeoutMS).
Con un poco más de trabajo podría crear un buen modal,aunque luce bastante bien para un estilo sobrio.

					VIDEO 314 CONTENIDO DEL MODAL

FH me proporciona el formulario del modal en recursos.TAmbién vamos a usar la libreria react date-time picker que ya está testeada:
>npm i react-datetime-picker

NOTA:recuerda preguntar si el trabajo es con clases o con hooks

Fijate que fácil es trabajar con fechas con moment:
// 3:45:50s no quiero esto,quiero horas exactas
const startDate = moment().minutes(0).seconds(0).add(1,'hours')
// con esto será siempre la siguiente hora

Sintaxis moment() me da un nuevo Date,pero lo configuro con minutes(number) | seconds(number) y con add(number,type).Amazing.

NOTA:fijate que puedo declarar lo que necesite fuera(arriba) del functional component.Asi sólo se ejecutará una vez:

// en React o Angular apuntar al selector más alto
Modal.setAppElement('#root');

// 3:45:50s no quiero esto,quiero horas exactas
const startDate = moment().minutes(0).seconds(0).add(1,'hours')
// con esto será siempre la siguiente hora

export const CalendarModal = () => {
* Al declararlo arriba me aseguro que solo se ejecuta una vez.

NOTA: dado que en JS todo pasa por referencia,para evitar modificar la primera variable moment tiene su método propio clone que crea un clon de una fecha :

const now = moment().minutes(0).seconds(0).add(1,'hours')
const nowPlus1= now.clone().add(1,'hours')

NOTA: hay otra libreria react-datetime (sin el picker).Hay que traerse el DatePicker en vez de el DateTimePIcker

			VIDEO 315 OBTENER LA INFORMACIÓN DEL FORMULARIO DEL EVENTO

NOTA:fijate que tengo tanto add como substract
  const yesterday = moment(dateStart).subtract(1, 'day')
  const valid = (current) => {
    return current.isAfter(yesterday);
  };

En cuanto a rescatar el formulario no es nada complicado:

const handleInputChange = ( {target} ) => {
    setFormValues({
      ...formValues,
      [target.name]: target.value,
    });
  }
  

  const handleStartDateChange = (date) => {
    setDateStart(date._d);
    setFormValues({
      ...formValues,
      start: date._d,
    });
  }

  const handleEndDateChange = (date) => {
    setDateEnd(date._d);
    setFormValues({
      ...formValues,
      end: date._d,
    });
  }

  const handleSubmitForm = (e) => {
    e.preventDefault();
    console.log(formValues);
  }

*IMPORTANTE:fijate que la clave de pasarle campos de diferentes tipos estuvo en la inicialización del estado del form:
 const [formValues, setFormValues] = useState({
    title:'Evento',
    notes:'', 
    start:now.toDate(),
    end:nowPlus1.toDate(),
  });
Podria pasarle un file,lo que rescate de un select,... esto es sólo el estado final del form.

				VIDEO 316 VALIDACIONES DEL FORMULARIO

Para comparar fechas es más fácil trabajarlas con moment.Fijate que debería tratar de hacer algun buen tutorial sobre esta libreria:

NOTA: una instancia de moment es un objeto grande,con muchas propiedades:

console.log(momentStart);
console.log(momentEnd);
_d: Mon Nov 29 2021 16:00:00 GMT+0100 (hora estándar de Europa central) {}
_i: Mon Nov 29 2021 16:00:00 GMT+0100 (hora estándar de Europa central) {}
_isAMomentObject: true
_isUTC: false
_isValid: true
_locale: Locale {_calendar: {…}, _longDateFormat: {…}, _invalidDate: 'Fecha inválida', _ordinal: '%dº', _dayOfMonthOrdinalParse: /\d{1,2}º/, …}
_pf: {empty: false, unusedTokens: Array(0), unusedInput: Array(0), overflow: -2, charsLeftOver: 0, …}

Pero si le paso el método toDate() pasa a ser una Date de Javascript:

console.log(momentStart.toDate());
console.log(momentEnd.toDate());
Mon Nov 29 2021 15:00:00 GMT+0100 (hora estándar de Europa central)
Mon Nov 29 2021 16:00:00 GMT+0100 (hora estándar de Europa central)
 
De igual forma puedo usar el método moment(JSDate) para pasar una instancia de Date de JS a una instancia de moment(es como JSOn.parse y JSON.stringify):

const momentStart = moment(start);
const momentEnd = moment(end);

Asi que con estos dos métodos paso de JS a moment y viceversa.Como es mucho más fácil comparar instancias de moment que de Date pasamos start y end a instancias de moment. 

   if (momentStart.isSameOrAfter(momentEnd)) {
      console.log('La fecha inicial debe ser menor que la final')
      return;
    }
* Para comparar tengo isAfter,isBefore,isSameOrAfter,isBeforeOrAfter,...
Lógicamente,el usuario necesita feedback de lo que ha sucedido asi que vamos a usar Sweetalert.
NOTA:nada me impide retornar el Swal.fire,dado que debo hacer un return y un Swal.fire puedo combinarlo:

 if (momentStart.isSameOrAfter(momentEnd)) {
      return Swal.fire({
        title: 'Error',
        text: 'La fecha final debe ser mayor que la inicial',
        icon: 'error',
        confirmButtonText: 'Ok'
      })
Fijate que es lo mismo que Swal.fire() + return,va a salirse y además con el Swal.fire.Perfecto.

Lo mismo podría hacer para evaluar el input para el title del evento,pero como es un input lo podemos hacer con bootstrap en vez de Swal y asi vemos dos formas.
* Habrá que usar otro estado local
const [ titleValid,setTitleValid] = useState(true);
* De nuevo fijate como combino la funcionalidad de un return con un setter:
 if(title.trim().length < 2){
      return setTitleValid(false);
    }
Nada me impide retornar el setter,saliendome de la funcion padre de este if.


			VIDEO 317 INSTALACION Y CONFIGURACION DE REDUX

Si bien podemos usar el Context de React vamos a usar Redux de nuevo.Vamos a instalar redux, react-redux, y thunk(redux-thunk) para asincronia.
>npm i redux react-redux redux-thunk
Creo los folders tipicos(types,actions,reducers,store).Empiezo con los types que es lo más fácil:
export const types = {
  uiOpenModal:'[ui] Open modal',
  uiCloseModal:'[ui] Close modal',
}

El primer reducer de momento es sólo para el modal,muy simple:

const initialState = {
  modalOpen: false,
};

export const uiReducer = (state = initialState, action) => {  
  switch (action.type) {
    case types.uiOpenModal:
      return {
        ...state,
        modalOpen: true,
      };
    case types.uiCloseModal:
      return {
        ...state,
        modalOpen: false,
      };
    default:
      return state;
  }
}

Fijate que Fernando va a crear un file rootReducer para combinar todos los reducers.Es una gran idea ya que realmente es otro reducer(luego está bien ubicado en le folder reducers) y además deja claro lo que hará:

import { combineReducers } from 'redux';
import { uiReducer } from './uiReducer';

export const rootReducer = combineReducers({
  ui: uiReducer,
  // TODO AuthReducer
  // TODO CalendarReducer
});
Usaremos tres en esta app,ya los agregaré.Perfecto,crearé el store.js:

import { createStore, applyMiddleware,compose } from 'redux';
import thunk from 'redux-thunk';
import { rootReducer } from '../reducers/rootReducer';

// si existen las herramientas para redux en mis DevTools las va a configurar,si no pues no hace nada ya que no existen :D
const composeEnhancers = (typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) || compose;

// createStore necesita un reducer como primer arg,logicamente será la combinación de todos ellos.
export const store  = createStore(
  rootReducer,
  composeEnhancers(applyMiddleware(thunk))
)
Fijate que queda mucho más claro para mi esta forma,sacando el rootReducer a otro lado.Por último proveo a mi App de este store en un punto alto:

import { Provider } from "react-redux";
import { store } from "./store/store";

import AppRouter from "./routers/AppRouter"

const CalendarApp = () => {
  return (
    <Provider store={store}>
      <AppRouter />
    </Provider>
  )
}
Como puedo ver es realmente sencillo usar redux.

			VIDEO 318 MOSTRAR Y OCULTAR MODAL EN BASE AL STORE

Fijate que se me olvidaron las actions,son importantes porque me permiten meter en una función cuanta funcionalidad desee para una acción:

* en vez de poner el tipo,el payload,etc en el dispatch...
 dispatch({type:types.uiOpenModal}) <- en vez de disparar esto
* simplemente llamo a una acción.Ya desarrollaré la lógica en ella
 dispatch(uiOpenModal())

En las actions si que desarrollo cualquier lógica necesaria:

export const uiOpenModal = () => ({
  type: types.uiOpenModal,
});

export const uiCloseModal = () => ({
  type: types.uiCloseModal,
});
Puedo observar que realmente son necesarias,en cuanto haya un poco de lógica las actions son 100% necesarias.

NOTA: el equipo de Redux creó una librería que reduce la cantidad de código necesario y la complejidad de Redux(esta librería es Redux-toolkit).Es la que usa lama

		VIDEO 319 CALENDARREDUCER Y PRIMERAS ACCIONES CON LOS EVENTOS

De momento creamos dos nuevos tipos y acciones:

export const setActiveEvent = (event) => ({
  type: types.eventSetActive,
  payload: event
})

export const eventAddNew = (event) => ({
  type: types.eventAddNew,
  payload: event
})
En el click del evento simplemente llamamos a la action setActiveEvent

Adicionalmente vamos a crear un fab(floating action button) que abra el modal también.No puede ser más fácil:

export const AddNewFab = () => {
  const dispatch = useDispatch()

  const openModal = () => {
    dispatch(uiOpenModal())
  }

  return (
    <button className="btn btn-primary fab"
    onClick={openModal}>
      <i className="fas fa-plus"></i>
    </button>
  )
}
En los estilos lo pongo en fixed y right y bottom a 25px siempre va a quedar alli.Como icono tenia el +,le subo un poco la fuente le doy un padding y border-radius a 50%.

